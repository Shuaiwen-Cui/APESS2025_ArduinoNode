{"config":{"lang":["en","zh"],"separator":"[\\s\\u200b\\-_,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ArduinoNode","text":"<p>This project will show you how to build a simple IoT wireless sensor node/network using Arduino Uno R4 WiFi.</p> <p>Tip</p> <p>The code in this project is far from perfect. Its main focus is to demonstrate key concepts and implementations of IoT wireless sensor networks from a theoretical perspective. There may be some less elegant parts in the code, and suggestions for improvement are welcome.</p> <p></p>"},{"location":"APESS2025HANDSON/apess2025/","title":"APESS2025-Arduino IOT WSN","text":""},{"location":"APESS2025HANDSON/apess2025/#time","title":"Time","text":"<p>Jul 29, 2025 14:00 - 17:15</p>"},{"location":"APESS2025HANDSON/apess2025/#venue","title":"Venue","text":"<p>TU103 &amp; ZS1107 @ PolyU HK</p>"},{"location":"APESS2025HANDSON/apess2025/#section-1-hardware-assembly-and-programming","title":"Section 1 Hardware Assembly and Programming","text":"<ul> <li> Hardware Assembly</li> <li> Configure, Program, and Flash Arduino Nodes</li> </ul>"},{"location":"APESS2025HANDSON/apess2025/#section-2-sensor-deployment-and-testing","title":"Section 2 Sensor Deployment and Testing","text":"<ul> <li> Deploy Sensors for Vibration Testing</li> <li> Post-Deployment Data Processing and Analysis</li> </ul>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/","title":"HARDWARE ASSEMBLY","text":""},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#item-list","title":"Item List","text":"Component Description Arduino UNO R4 WiFi Main controller for the node, providing processing power and connectivity. Sensor Shield A shield that connects to the Arduino for easy sensor integration. MPU6050 An acceleration sensor that measures motion and orientation. SD Module &amp; Card Used for data storage, allowing the node to log sensor data. RGB LED Provides visual feedback, indicating the status of the node. NRF24L01 Module &amp; Antenna Enables local wireless communication between nodes. BMS &amp; Battery Provides power to the entire node, making it portable. Enclosure Protects internal electronic components and provides a pretty appearance."},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#1-battery-box-installation","title":"1 Battery Box Installation","text":"<p>As shown in the pictures, take the battery box out of the packaging bag and use a screwdriver, screws, and bolts to secure it to the mounting board.</p> <p>Caution</p> <p>Ensure the installation position and orientation of the battery box are correct, referring to the examples in the images to ensure the smooth installation of subsequent components.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#2-main-control-board-installation","title":"2 Main Control Board Installation","text":"<p>Install the main control board (Arduino UNO R4 WiFi) onto the corresponding mounting board using screws and bolts. Ensure the board is securely fastened.</p> <p>Caution</p> <p>Ensure the installation position of the main control board is correct, and that all connectors and interfaces are facing an accessible direction for subsequent connections to other components. You can refer to the examples in the images for installation.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#3-sensor-shield-assembly","title":"3 Sensor Shield Assembly","text":"<p>Install the sensor shield (Sensor Shield) onto the main control board. Ensure all pins are correctly aligned and securely connected.</p> <p>Caution</p> <p>Make sure the sensor shield is firmly attached to the main control board and that the pins are aligned, referring to the markings near the pins. All connections should be secure to prevent disconnection during operation.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#4-mpu6050-installation","title":"4 MPU6050 Installation","text":"MCU Pin MPU6050 Pin VCC VCC GND GND SDA SDA SCL SCL -- INT <p>As shown in the figure, the MPU6050 sensor needs to be connected to the main control board via the I2C interface. Using the 4-pin cable provided with the MPU6050, connect the VCC pin of the MPU6050 to the VCC pin of the Arduino, the GND pin to GND, the SDA pin to SDA, and the SCL pin to SCL. The INT pin can be left unconnected.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#5-rf24l01-module-installation","title":"5 RF24L01 Module Installation","text":"<p>As shown in the figure, after assembling the RF module, simply plug it into the sensor shield. Ensure that the pins of the RF module are correctly aligned and securely connected.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#6-rgb-led-installation","title":"6 RGB LED Installation","text":"Arduino Pin 6812 RGB LED Pin V V G G S \uff08D7\uff09 S <p>Connect the RGB LED to the sensor shield using the associated Dupont wires. Connect the RGB LED's pins to the corresponding pins on the sensor shield.</p> <p>Caution</p> <p>Ensure the RGB LED is connected correctly, with the V pin to V, G pin to G, and S pin to D7. This will ensure proper operation of the LED for visual feedback.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#7-sd-module-installation","title":"7 SD Module Installation","text":"Arduino Pin SD Card Module Pin 5V VCC GND GND D10 CS D11 MOSI D12 MISO D13 SCK <p>As shown in the figure, the SD card module needs to be connected to the main control board via the SPI interface.</p> <p>Caution</p> <p>Ensure the connections of the SD card module are correct and secure. If the dupont wires are loose, please replace them or contact technical support.</p>"},{"location":"APESS2025HANDSON/ASSEMBLY/assembly/#8-enclosure-assembly","title":"8 Enclosure Assembly","text":"<p>Caution</p> <p>This step should be performed after programming is complete to ensure all components can be correctly placed.</p> <ul> <li> <p>Use the standoffs and bolts to secure the battery box and the mounting board where the main control board is located.</p> </li> <li> <p>Put the batteries into the battery box, ensuring they are correctly oriented. Don't press to hard, as it cannot be fully pressed down due to the mismatch of the size of the battery box and the battery.</p> </li> <li> <p>Put the whole node into the enclosure, ensuring all components are securely placed and that the enclosure is closed properly.</p> </li> </ul> <p>Caution</p> <p>How the node should be placed inside the enclosure is up to the specific requirements of the experiment being conducted.</p>"},{"location":"APESS2025HANDSON/DEPLOYMENT/deployment/","title":"Sensor Deployment","text":""},{"location":"APESS2025HANDSON/DEPLOYMENT/deployment/#laboratory-test-cantilever-beam-experiment","title":"Laboratory Test - Cantilever Beam Experiment","text":""},{"location":"APESS2025HANDSON/DEPLOYMENT/deployment/#test-time-and-location","title":"Test Time and Location","text":"<p>Date: July 29, 2025 4:00 PM - 5:00 PM Location: ZS1107</p>"},{"location":"APESS2025HANDSON/DEPLOYMENT/deployment/#objectives","title":"Objectives","text":"<ul> <li>Learn to use a wireless sensor network for data acquisition and transmission  </li> <li>Calibrate the sensors</li> </ul>"},{"location":"APESS2025HANDSON/DEPLOYMENT/deployment/#equipment","title":"Equipment","text":"<ul> <li>ArduinoNode  </li> <li>Wired sensors  </li> <li>Cantilever beam structure</li> </ul>"},{"location":"APESS2025HANDSON/DEPLOYMENT/deployment/#test-procedure","title":"Test Procedure","text":"<ul> <li>After placing the sensors into their enclosures, fix and attach them securely to the cantilever beam. Ensure the wired sensor and the ArduinoNode sensor are placed closely and firmly together.</li> <li>Simultaneously collect data from both the wired sensor and the ArduinoNode sensor.</li> <li>Retrieve sensor data from the SD card module.</li> <li>Plot the time-history curves and frequency spectra of the sensor data.</li> <li>Calibrate the scaling factors of the three axes of the sensor.</li> </ul>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/","title":"PROGRAMMING","text":""},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#1-preparation","title":"1 PREPARATION","text":""},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#11-install-vscode","title":"1.1 Install VSCode","text":"<ul> <li> <p> VSCode</p> <p>  Download Link </p> </li> </ul>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#12-install-platformio","title":"1.2 Install PlatformIO","text":"<p>(1) Open VSCode Extension Manager</p> <p>(2) Search for official PlatformIO IDE extension</p> <p>(3) Install PlatformIO IDE.</p>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#13-install-serial-monitor","title":"1.3 Install Serial Monitor","text":"<p>(1) Open VSCode Extension Manager</p> <p>(2) Search for official Serial Monitor extension</p> <p>(3) Install Serial Monitor extension.</p>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#14-download-project-code","title":"1.4 Download Project Code","text":"<p>Choose one of the following two options:</p> <ul> <li> <p> Google Drive</p> <p>  Download Link </p> </li> <li> <p> GitHub</p> <p>  Download Link </p> </li> </ul> <p>After downloading, extract the files to your chosen directory.</p>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#2-programming","title":"2 PROGRAMMING","text":""},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#21-open-project-in-vscode","title":"2.1 Open Project in VSCode","text":"<p>(1) Launch VSCode.</p> <p>(2) Open the folder where you extracted the project code.</p> <p>(3) You should see the project structure in the Explorer panel.</p>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#22-task-1-modify-configuration-file","title":"2.2 TASK 1 - Modify Configuration File","text":"<p>Open the <code>src/config.h</code> file in the project directory. You will see a section like this:</p> <p><pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n\n/* Node Information */\n// #define GATEWAY          // for main node\n#define LEAFNODE        // for sensor node\n\n// #define NODE_ID 100      // GATEWAY should be 100\n#define NODE_ID 1 // for LEAFNODE: 1, 2, 3, 4, 5, 6, 7, 8\n// #define NODE_ID 2\n// #define NODE_ID 3\n// #define NODE_ID 4\n// #define NODE_ID 5\n// #define NODE_ID 6\n// #define NODE_ID 7\n// #define NODE_ID 8\n\n#define NUM_NODES 8 // Total number of nodes in the network\n\n/* WiFi Credentials */\n#define WIFI_SSID \"Shaun's Iphone\"\n#define WIFI_PASSWORD \"cshw0918\"\n\n/* MQTT Configurations */\n// #define MQTT_CLIENT_ID      \"GATEWAY\"\n#define MQTT_CLIENT_ID      \"LEAFNODE1\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE2\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE3\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE4\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE5\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE6\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE7\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE8\"\n\n#define MQTT_BROKER_ADDRESS \"8.222.194.160\"\n#define MQTT_BROKER_PORT    1883\n#define MQTT_USERNAME       \"ArduinoNode\"\n#define MQTT_PASSWORD       \"Arduino123\"\n#define MQTT_TOPIC_PUB      \"ArduinoNode/node\"\n#define MQTT_TOPIC_SUB      \"ArduinoNode/server\"\n\n// Sensing Variables \nextern uint64_t sensing_scheduled_start_ms; // Scheduled sensing start time (Unix ms)\nextern uint64_t sensing_scheduled_end_ms;   // Scheduled sensing end time (Unix ms)\nextern uint32_t sensing_rate_hz;            // Sensing rate in Hz\nextern uint32_t sensing_duration_s;         // Sensing duration in seconds\nextern uint32_t default_sensing_rate_hz;   // Default sensing rate in Hz\nextern uint32_t default_sensing_duration_s; // Default sensing duration in seconds\nextern uint16_t parsed_freq;                // Parsed frequency from command\nextern uint16_t parsed_duration;            // Parsed duration from command\nextern float cali_scale_x; // Calibration scale for X-axis\nextern float cali_scale_y; // Calibration scale for Y-axis\nextern float cali_scale_z; // Calibration scale for Z-axis\n\n/* Serial Configurations */\n// #define DATA_PRINTOUT // Enable data printout to Serial\n\n// === Function Declaration ===\nvoid print_node_config();\n</code></pre> You need to modify two parts:</p> <ol> <li> <p><code>NODE_ID</code>: Set it to your group number (1-8). For example, if you are in group 5, uncomment the corresponding <code>NODE_ID</code> line and comment out the others.</p> </li> <li> <p><code>MQTT_CLIENT_ID</code>: Set it to your group number (1-8). For example, if you are in group 5, uncomment the corresponding <code>MQTT_CLIENT_ID</code> line and comment out the others.</p> </li> </ol>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#23-task-2-complete-the-sensing-code","title":"2.3 TASK 2 - Complete the Sensing Code","text":"<p>In the <code>src/sensing.cpp</code> file, you need to complete the code for sensor data acquisition. Open the file and find the following commented section:</p> <pre><code>void sensing_sample_once()\n{\n    // Check current time\n    uint32_t now_ms = Time.get_time();\n\n    // Check if we should sample\n    if (now_ms - last_sample_time &gt;= (1000 / sensing_rate_hz))\n    {\n        // if yes, update the last sample time\n        last_sample_time += (1000 / sensing_rate_hz);\n\n        // Prepare the variables for reading IMU data\n        int16_t ax, ay, az;\n\n        // &lt;Read acceleration data from the IMU, to be completed by students, refering to mpu6050.hpp and mpu6050.cpp&gt;\n\n        // Calculate the elapsed time since the start of sensing\n        uint32_t elapsed = now_ms - t_start_ms;\n\n        // Converting raw acceleration data to g's using the scaling factor and calibration factors\n        float ax_g = ax * cali_scale_x / 16384.0f;\n        float ay_g = ay * cali_scale_y / 16384.0f;\n        float az_g = az * cali_scale_z / 16384.0f;\n\n        // print the data to the SD card file\n        char line[64];\n        snprintf(line, sizeof(line), \"%8lu,%8.6f,%8.6f,%8.6f\", elapsed, ax_g, ay_g, az_g);\n        data_file.println(line);\n\n        // Update the number of samples taken\n        sample_count++;\n    }\n}\n</code></pre> <p>In the section marked <code>&lt;Read acceleration data from the IMU, to be completed by students, refering to mpu6050.hpp and mpu6050.cpp&gt;</code>, you need to call the functions in the IMU library to read the acceleration data. The specific functions can be found in the <code>mpu6050.hpp</code> and <code>mpu6050.cpp</code> files. This function is key to sensing and can help you better understand the process of acquiring sensor data.</p>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#24-compile-and-upload-code","title":"2.4 Compile and Upload Code","text":"<p>Make sure that the code is complete and verified, and consult your instructor or technical support if needed. Then follow the steps below to compile and upload the code:</p> <p></p> <ol> <li>Ensure that the development board is connected to the computer via a Type-C cable.</li> <li>In the PlatformIO toolbar at the bottom of VSCode, click the \"Build\" button to compile the code.</li> <li>Once the compilation is complete, click the \"Upload\" button to upload the code to the development board.</li> </ol>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#25-view-serial-output","title":"2.5 View Serial Output","text":"<p>You can use PlatformIO\u2019s built-in serial monitor to view the output from the development board. Click the \"Serial Monitor\" button at the bottom, select the correct COM port (usually COM3 or a similar name), set the baud rate to 115200, and then click \"Connect\" to view the output.</p> <p>Warning</p> <p>Only one program can access the serial port at a time. Make sure no other programs are occupying the port. Note that when flashing the firmware, you should close any serial communication first, otherwise the upload might fail.</p>"},{"location":"APESS2025HANDSON/PROGRAMMING/programming/#3-testing","title":"3 TESTING","text":"<p>After uploading the code, you can check if the system is functioning correctly by observing the RGB LED colors and the serial output.</p> <p>Tip</p> <p>If the RGB LED color is always white, it indicates that there is a problem during the initialization process. Please check the hardware connections. A sky blue state indicates RF communication, meaning it is waiting to communicate with the main node and needs to be tested in conjunction with the main node's signal. Green indicates that initialization is complete and it has entered the IDLE state, waiting for commands from the main node. Yellow is the preparation state before data collection, purple is the state of data collection, and red is the error state, which may be caused by sensor initialization failure or other issues.</p>"},{"location":"DATASHEET/datasheet/","title":"DATASHEET","text":""},{"location":"DATASHEET/datasheet/#main-controller","title":"Main Controller","text":"Item Specification MCU Renesas RA4M1 Clock Speed 48 MHz RAM 32 KB Flash Storage 256 KB"},{"location":"DATASHEET/datasheet/#acceleration-measurement","title":"Acceleration Measurement","text":"Item Specification Accelerometer MPU6050 Measurement Range \u00b12g / \u00b14g / \u00b18g / \u00b116g Resolution 16-bit Noise Level 0.0004 g/\u221aHz <p>Tip</p> <p>The highest sampling rate tested during development is 250Hz, higher rates are not tested. The longest sampling duration tested is 5 minutes; longer durations are untested, with the theoretical duration being the SD card capacity divided by the sampling rate.</p>"},{"location":"DATASHEET/datasheet/#wireless-communication","title":"Wireless Communication","text":"<ul> <li>WiFi</li> <li>nRF24L01</li> </ul> <p>Tip</p> <p>In practical tests, the WiFi module's effective range when connected to a mobile hotspot is approximately 20 meters (tested in an elevated pedestrian bridge environment over a highway).</p> <p>Tip</p> <p>The wireless communication module has been tested at a rate of 250Kbps, with a theoretical maximum communication distance of up to 1100 meters. The longest communication distance tested during development is approximately 25m; longer distances are untested.</p>"},{"location":"DATASHEET/datasheet/#storage","title":"Storage","text":"<ul> <li>Supports up to 32 GB SD card, higher capacity SD cards are untested.</li> </ul>"},{"location":"DATASHEET/datasheet/#power-supply","title":"Power Supply","text":"<ul> <li>Operating Voltage: 5V</li> <li>Power Module: 3.7V Li-ion battery (2 \u00d7 18650)</li> </ul>"},{"location":"DEMO/demo/","title":"DEMO","text":""},{"location":"DEMO/field-test1/","title":"FIELD TEST 1","text":""},{"location":"DEMO/field-test1/#the-footbridge-over-nanyang-lake-at-nanyang-technological-university","title":"The Footbridge over Nanyang Lake at Nanyang Technological University","text":""},{"location":"DEMO/field-test1/#wsn-setup","title":"WSN Setup","text":""},{"location":"DEMO/field-test1/#sampling-setup","title":"Sampling Setup","text":"<p>Excitation Method: Shaking the handrail by hand, lasting about 2-3 seconds each time.</p> <p>Sampling Frequency: 200Hz</p> <p>Sampling Duration: 300 seconds</p>"},{"location":"DEMO/field-test1/#data-analysis","title":"Data Analysis","text":""},{"location":"DEMO/field-test1/#time-history","title":"Time History","text":""},{"location":"DEMO/field-test1/#frequency-spectrum-analysis","title":"Frequency Spectrum Analysis","text":""},{"location":"DEMO/field-test2/","title":"FIELD TEST 2","text":""},{"location":"DEMO/field-test2/#footbridge-over-highway","title":"Footbridge over Highway","text":""},{"location":"DEMO/field-test2/#wsn-setup","title":"WSN Setup","text":""},{"location":"DEMO/field-test2/#sampling-setup","title":"Sampling Setup","text":"<p>Excitation Method: No manual excitation, relying on vibrations from passing vehicles.</p> <p>Sampling Frequency: 200Hz</p> <p>Sampling Duration: 300 seconds</p>"},{"location":"DEMO/field-test2/#data-analysis","title":"Data Analysis","text":""},{"location":"DEMO/field-test2/#time-history","title":"Time History","text":""},{"location":"DEMO/field-test2/#frequency-spectrum-analysis","title":"Frequency Spectrum Analysis","text":""},{"location":"DEMO/lab-test/","title":"LABORATORY TESTS","text":""},{"location":"DEMO/lab-test/#test-goals","title":"TEST GOALS","text":"<ul> <li> <p>To test the basic sampling and transmission capabilities of the ArduinoNode.</p> </li> <li> <p>To cross-verify the data with a known good sensor by conducting modal analyses.</p> </li> </ul>"},{"location":"DEMO/lab-test/#test-procedure-ambient-vibration","title":"TEST PROCEDURE - Ambient Vibration","text":"<ul> <li> <p>Set up the Arduino Nodes.</p> </li> <li> <p>Set up PCB sensors along side the Arduino Nodes.</p> </li> <li> <p>Issue commands to the Arduino Nodes to sample data at prescribed time, sampling rate, and duration. (100Hz sampling for 5 minutes)</p> </li> <li> <p>Issue commands to the PCB sensors to sample data at prescribed time, sampling rate, and duration. The duration should cover the time period of the Arduino Node sampling.  (100Hz sampling for 5 minutes)</p> </li> <li> <p>Receive the data from the Arduino Nodes and PCB sensors.</p> </li> </ul>"},{"location":"DEMO/lab-test/#test-procedure-free-vibration","title":"TEST PROCEDURE - Free Vibration","text":"<ul> <li> <p>Set up the Arduino Nodes.</p> </li> <li> <p>Set up PCB sensors along side the Arduino Nodes.</p> </li> <li> <p>Issue commands to the Arduino Nodes to sample data at prescribed time, sampling rate, and duration. (100Hz sampling for 2 minutes)</p> </li> <li> <p>Issue commands to the PCB sensors to sample data at prescribed time, sampling rate, and duration. The duration should cover the time period of the Arduino Node sampling.  (100Hz sampling for 2 minutes)</p> </li> <li> <p>Receive the data from the Arduino Nodes and PCB sensors.</p> </li> </ul>"},{"location":"DEMO/lab-test/#results-analysis","title":"RESULTS ANALYSIS","text":""},{"location":"DEMO/lab-test/#time-history","title":"Time History","text":""},{"location":"DEMO/lab-test/#frequency-spectrum","title":"Frequency Spectrum","text":""},{"location":"DEMO/timesynctest/","title":"Time Synchronization Test","text":"<p>This test evaluates the time synchronization performance of a wireless sensor network. The sensors are arranged in a circle on the same table, equidistant from the center. A rhythmic tapping is performed at the center's vacant position to analyze peak delays and calculate synchronization performance among sensors. The method used is cross-correlation analysis, which computes the cross-correlation function between different sensors and the master node to determine peak delays.</p>"},{"location":"DEMO/timesynctest/#time-history","title":"Time History","text":""},{"location":"DEMO/timesynctest/#delay-analysis","title":"Delay Analysis","text":""},{"location":"HARDWARE/hardware/","title":"HARDWARE","text":"<p>Item List:</p> Component Description Arduino UNO R4 WiFi Main controller for the node, providing processing power and connectivity. Sensor Shield A shield that connects to the Arduino for easy sensor integration. MPU6050 An acceleration sensor that measures motion and orientation. SD Module &amp; Card Used for data storage, allowing the node to log sensor data. RGB LED Provides visual feedback, indicating the status of the node. NRF24L01 Module &amp; Antenna Enables local wireless communication between nodes. BMS &amp; Battery Provides power to the entire node, making it portable. Enclosure Protects internal electronic components and provides a pretty appearance. <p>Note</p> <p>These components together form a fully functional IoT wireless sensor node capable of collecting data, storing information, and communicating wirelessly. Each component plays a crucial role in ensuring the efficient operation and reliability of the node.</p>"},{"location":"HARDWARE/ACCELERATION/acceleration/","title":"ACCELERATION SENSOR -- MPU6050","text":"<p>MPU6050</p> <p>The MPU6050 is in fact an inertial measurement unit (IMU) that integrates a 3-axis gyroscope and a 3-axis accelerometer. It is widely used in various applications such as robotics, drones, and motion tracking. Here, we only use the accelerometer part of the MPU6050 to measure acceleration in three axes (X, Y, Z).</p> <p></p>"},{"location":"HARDWARE/ACCELERATION/acceleration/#specifications","title":"SPECIFICATIONS","text":"Feature Specification Operating Voltage 3.3V to 5V Communication Interface I2C Measurement Range \u00b12g, \u00b14g, \u00b18g, \u00b116g (configurable) Resolution 16 bits Sensitivity 16384 LSB/g (for \u00b12g range)"},{"location":"HARDWARE/ACCELERATION/acceleration/#wiring","title":"WIRING","text":"<p>The wiring of the MPU6050 is straightforward. It typically uses the I2C protocol for communication, which requires only two wires (SDA and SCL) in addition to power and ground connections.</p> <p></p> MCU Pin MPU6050 Pin VCC VCC GND GND SDA SDA SCL SCL -- INT <p>Note</p> <p>The INT pin is optional and can be used for interrupt-driven applications. For basic applications, you can leave it unconnected. In this project, we will not use the INT pin.</p> <p>Caution</p> <p>Although the MPU6050 is inexpensive and easy to use, its accuracy and stability are relatively poor. Tests have shown that it is more suitable for laboratory environments with strong excitation applications, while in practical applications, it is recommended to use higher precision sensors.</p>"},{"location":"HARDWARE/ENCLOSURE/enclosure/","title":"ENCLOSURE","text":"<p>This project involves an enclosure that is designed to house various components. The enclosure is constructed from durable materials to ensure longevity and protection for the internal components.</p>"},{"location":"HARDWARE/ENCLOSURE/enclosure/#enclosure-design","title":"Enclosure Design","text":""},{"location":"HARDWARE/ENCLOSURE/enclosure/#enclosure-images","title":"Enclosure Images","text":"<p>Top View</p> <p> </p> <p>Front View </p> <p>Side View </p>"},{"location":"HARDWARE/MCU/mcu/","title":"MAIN CONTROLLER BOARD","text":"<p>Main Controller Board</p> <p>In this project\uff0c the main controller board serves two purposes: central control and Wi-Fi communication.</p>"},{"location":"HARDWARE/MCU/mcu/#main-controller-board-appearance","title":"Main Controller Board Appearance","text":""},{"location":"HARDWARE/MCU/mcu/#main-controller-board-pin-layout","title":"Main Controller Board Pin Layout","text":""},{"location":"HARDWARE/MCU/mcu/#reference-links","title":"Reference Links","text":"<ul> <li> <p> ARDUINO UNO R4 WIFI</p> <p>  LINK </p> </li> </ul>"},{"location":"HARDWARE/POWER/power/","title":"POWER SUPPLY","text":"<p>Power Supply</p> <p>Power supply ensures that the device can operate stably. The Arduino Node can be powered in various ways, including USB, external power adapters, and batteries. Choosing the right power supply method can improve the reliability and performance of the device. This section mainly introduces battery-powered methods to adapt to outdoor environments.</p> <p></p>"},{"location":"HARDWARE/POWER/power/#battery","title":"Battery","text":"<p>As shown in the figure, this project uses two 18650 lithium batteries for power supply. The 18650 lithium battery is a commonly used rechargeable battery with high energy density and long service life. They are typically used in portable electronic devices and power tools.</p>"},{"location":"HARDWARE/POWER/power/#battery-holder","title":"Battery Holder","text":"<p>To facilitate the installation and replacement of batteries, this project uses a 18650 battery holder. The battery holder can accommodate two 18650 lithium batteries and provides the necessary connection interface. It is usually equipped with an indicator light, allowing users to easily check the battery status.</p>"},{"location":"HARDWARE/RADIOFREQUENCY/radiofrequency/","title":"RADIO FREQUENCY","text":"<p>Radio frequency (RF) module nRF24L01 is a low-power, low-cost 2.4GHz wireless transceiver suitable for short-range wireless communication. It supports multiple data rates and multi-channel operation, has strong anti-interference capabilities, and offers a longer transmission distance. Compared to Wifi, radio frequency features low latency, low power consumption, and is more suitable for applications requiring real-time data transmission.</p>"},{"location":"HARDWARE/RADIOFREQUENCY/radiofrequency/#parameters","title":"Parameters","text":"<p>nRF24L01 Technical Specifications</p> Parameter Description Frequency 2.4 GHz ISM band Data Rate 250 kbps / 1 Mbps / 2 Mbps Operating Voltage 1.9V \u2013 3.6V (Recommended: 3.3V) Range Approx. 10\u2013100 meters (depends on antenna) Interface SPI protocol RX Current Approx. 12.3 mA TX Current Approx. 11.3 mA (0 dBm output) Packet Size 1 to 32 bytes Address Width 3 to 5 bytes Features Auto-ACK, Auto-Retransmit, Multichannel RX"},{"location":"HARDWARE/RADIOFREQUENCY/radiofrequency/#wiring","title":"Wiring","text":"Pin Name Description 1 GND Ground 2 VCC Power supply (Recommended 3.3V, no 5V!) 3 CE Chip Enable (mode control: TX/RX switch) 4 CSN SPI Chip Select (active low) 5 SCK SPI Clock Input 6 MOSI Master Out Slave In 7 MISO Master In Slave Out 8 IRQ Interrupt Pin (optional) ```"},{"location":"HARDWARE/RGB-LED/rgbled/","title":"RGB LED","text":"<p>RGB LED</p> <p>RGB LED is a type of LED that can display multiple colors. It typically consists of three independent LEDs that emit red, green, and blue light. By adjusting the brightness of these three colors, various colors can be mixed.</p> <p></p>"},{"location":"HARDWARE/RGB-LED/rgbled/#wiring","title":"Wiring","text":"Arduino Pin 6812 RGB LED Pin V V G G S \uff08D7\uff09 S"},{"location":"HARDWARE/SDCARD/sdcard/","title":"SD CARD MODULE","text":"<p>SD Card Module</p> <p>The SD card module is an external storage device used for data storage. It communicates with Arduino via the SPI interface. The SD card module is typically used to store log data, configuration files, or other data that needs to be persistent.</p> <p></p>"},{"location":"HARDWARE/SDCARD/sdcard/#hardware-connections","title":"Hardware Connections","text":"Arduino Pin SD Card Module Pin 5V VCC GND GND D10 CS D11 MOSI D12 MISO D13 SCK <p>Note</p> <p>It is recommended to use SD cards with a capacity of 32GB or less, formatted in FAT32. Larger capacity SD cards may cause compatibility issues.</p>"},{"location":"HARDWARE/SHIELD/shield/","title":"SENSOR SHIELD","text":"<p>Sensor Shield</p> <p>The Sensor Shield is an expansion board designed for connecting various sensors, providing a rich set of interfaces and functionalities to facilitate sensor data acquisition and processing.</p> <p></p>"},{"location":"HARDWARE/TOUCH-SENSOR/touchsensor/","title":"TOUCH SENSOR","text":"<p>Touch Sensor</p> <p>A touch sensor is a device that detects the presence of a touch or contact with an object. It is commonly used in various electronic devices to enable user interaction.</p> <p></p>"},{"location":"HARDWARE/TOUCH-SENSOR/touchsensor/#wiring","title":"Wiring","text":"Arduino Pin 6812 RGB LED Pin V V G G S \uff08D3\uff09 S"},{"location":"SOFTWARE/software/","title":"SOFTWARE","text":"<p>By programming, we can implement various applications based on hardware functions. Under the condition of introducing various hardware libraries, we can encapsulate commonly used functions into functions for the main program to call. These functions can be divided into several groups: sensing, communication, storage, time control, interaction, etc.</p>"},{"location":"SOFTWARE/ARCHITECTURE/architecture/","title":"ARCHITECTURE","text":"<p>In this project, the dependency graph of the software architecture is as follows:</p> <pre><code>graph LR\n\n%% === Module Definitions ===\nconfig[\"config.hpp/.cpp\"]\nnodestate[\"nodestate.hpp/.cpp\"]\ntime[\"time.hpp/.cpp\"]\nmpu[\"mpu6050.hpp/.cpp\"]\nsd[\"sdcard.hpp/.cpp\"]\nrgb[\"rgbled.hpp/.cpp\"]\nlog[\"logging.hpp/.cpp\"]\nmqtt[\"mqtt.hpp/.cpp\"]\nmqttcmd[\"mqtt_cmd.hpp/.cpp\"]\nsensing[\"sensing.hpp/.cpp\"]\nsync[\"timesync.hpp/.cpp\"]\nwifi[\"wifi.hpp/.cpp\"]\nrf[\"rf.hpp/.cpp\"]\nrf_cmd[\"rf_cmd.hpp/.cpp\"]\nmain[\"main.cpp\"]\n\n%% === Module Relationships (Reversed Arrows) ===\nconfig --&gt; main\nnodestate --&gt; main\nrgb --&gt; main\nmpu --&gt; main\nsd --&gt; main\nrf --&gt; main\nwifi --&gt; main\ntime --&gt; main\nsync --&gt; main\nmqtt --&gt; main\nsensing --&gt; main\nrf_cmd --&gt; main\n\nnodestate --&gt; mqtt\nmqttcmd --&gt; mqtt\n\nconfig --&gt; mqttcmd\ntime --&gt; mqttcmd\nsync --&gt; mqttcmd\nnodestate --&gt; mqttcmd\nrgb --&gt; mqttcmd\nmqtt --&gt; mqttcmd\n\nconfig --&gt; sensing\nnodestate --&gt; sensing\ntime --&gt; sensing\nrgb --&gt; sensing\nmpu --&gt; sensing\nmqtt --&gt; sensing\nsd --&gt; sensing\nlog --&gt; sensing\nwifi --&gt; sensing\n\ntime --&gt; sync\nrf --&gt; sync\n\nsd --&gt; log\n\nnodestate --&gt; rgb\n\nlog --&gt; rf\ntime --&gt; rf\n\nrf --&gt; rf_cmd\nnodestate --&gt; rf_cmd\nrgb --&gt; rf_cmd\nconfig --&gt; rf_cmd\ntime --&gt; rf_cmd\n\nconfig --&gt; wifi\n\n</code></pre>"},{"location":"SOFTWARE/COMMAND-FEEDBACK/command/","title":"COMMAND","text":"<p>Controlling nodes is a crucial part of sensor node development. In traditional wireless sensor networks, this is often done by controlling the gateway node, which then communicates with other nodes wirelessly. For IoT nodes, we can leverage the internet for remote control. In this project, we achieve node control over the internet based on the MQTT callback mechanism. Let's first look at the code:</p> <pre><code>flowchart TD\n    %% === Participants ===\n    User[\"\ud83e\uddd1\u200d\ud83d\udcbb Remote User (PC / Cloud)\"]\n    MQTT[\"\u2601\ufe0f MQTT Broker\"]\n    Gateway[\"\ud83e\udde0 Main Node (WiFi + RF)\"]\n    Leaf[\"\ud83d\udd27 Leaf Node (RF only)\"]\n\n    %% === Data Flow ===\n    User --&gt;|\u2460 Send CMD_SENSING| MQTT\n    MQTT --&gt;|\u2461 Deliver command| Gateway\n    Gateway --&gt;|\u2462 Parse + Set flag| Gateway\n    Gateway --&gt;|\u2463 Send RF command| Leaf\n    Leaf --&gt;|\u2464 Parse + Schedule task| Leaf\n</code></pre>"},{"location":"SOFTWARE/COMMAND-FEEDBACK/command/#mqtt-part","title":"MQTT Part","text":"<p>We put the MQTT callback function in the mqtt_cmd.hpp and mqtt_cmd.cpp files. As shown in the code, the MQTT callback function will first match and parse the preset fields for the received command, extract the relevant variables for local assignment, and also set the flag or switch the state according to the command content.</p> <pre><code>// Callback when subscribed message is received\nvoid mqtt_callback(char *topic, byte *payload, unsigned int length)\n{\n    Serial.print(\"[COMMUNICATION] &lt;MQTT&gt; Message received [\");\n    Serial.print(topic);\n    Serial.print(\"]: \");\n\n    char message[length + 1];\n    for (unsigned int i = 0; i &lt; length; ++i)\n    {\n        message[i] = (char)payload[i];\n        Serial.print(message[i]);\n    }\n    message[length] = '\\0';\n    Serial.println();\n\n    // Clean trailing \\r or \\n\n    while (length &gt; 0 &amp;&amp; (message[length - 1] == '\\r' || message[length - 1] == '\\n'))\n    {\n        message[--length] = '\\0';\n    }\n\n    String msg_str(message);\n\n    if (msg_str == \"CMD_NTP\")\n    {\n        node_status.node_flags.gateway_ntp_required = true;\n        node_status.node_flags.leafnode_ntp_required = true;\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_NTP received.\");\n\n        // switch to COMMUNICATING state\n        node_status.set_state(NodeState::WIFI_COMMUNICATING);\n        rgbled_set_by_state(NodeState::WIFI_COMMUNICATING); // Set LED to blue during NTP sync\n    }\n    else if (msg_str == \"CMD_RF_SYNC\")\n    {\n        node_status.node_flags.time_rf_required = true;\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_RF_SYNC received.\");\n    }\n    else if (msg_str == \"CMD_SN\")\n    {\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_SN received.\");\n\n        node_status.node_flags.time_rf_required = true;\n\n        // Get current system time in milliseconds\n        uint64_t now_unix_ms = Time.get_time();\n        uint64_t now_unix_ms_rounded = (now_unix_ms / 1000) * 1000; // Round down to nearest second\n\n        // Schedule sensing: start after TIME_SYNC_RESERVED_TIME\n\n        sensing_duration_s = default_sensing_duration_s; // Use default duration\n        sensing_rate_hz = default_sensing_rate_hz;       // Use default rate\n\n        parsed_freq = default_sensing_rate_hz;    // global variable at config.hpp\n        parsed_duration = default_sensing_duration_s; // global variable at config.hpp\n\n        sensing_scheduled_start_ms = now_unix_ms_rounded + TIME_SYNC_RESERVED_TIME;\n        sensing_scheduled_end_ms = sensing_scheduled_start_ms + (sensing_duration_s * 1000);\n\n        // Set sensing flags\n        node_status.node_flags.sensing_requested = true;\n        node_status.node_flags.sensing_scheduled = true;\n\n        // Convert scheduled start time to human-readable calendar format\n        CalendarTime start_ct = calendar_from_unix_milliseconds(sensing_scheduled_start_ms);\n\n        // Print schedule details to Serial\n        char buf[128];\n        snprintf(buf, sizeof(buf),\n                 \"[MQTT] CMD_SN: Sensing scheduled at %04d-%02d-%02d %02d:%02d:%02d | Freq = %d Hz, Duration = %d s\",\n                 start_ct.year, start_ct.month, start_ct.day,\n                 start_ct.hour, start_ct.minute, start_ct.second,\n                 sensing_rate_hz, sensing_duration_s);\n        Serial.println(buf);\n\n        // Optionally publish feedback to MQTT broker\n        mqtt_client.publish(MQTT_TOPIC_PUB, \"CMD_SN: Sensing scheduled using default parameters.\");\n    }\n    else if (msg_str.startsWith(\"CMD_SFN_\"))\n    {\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_SFN received.\");\n\n        node_status.node_flags.time_rf_required = true;\n\n        int delay_sec, freq, duration;\n        int matched = sscanf(message, \"CMD_SFN_%d_%dHz_%ds\", &amp;delay_sec, &amp;freq, &amp;duration);\n\n        if (matched == 3)\n        {\n            if (delay_sec * 1000 &lt; TIME_SYNC_RESERVED_TIME)\n            {\n                Serial.println(\"[MQTT] CMD_SFN rejected: insufficient delay for time synchronization.\");\n                mqtt_client.publish(MQTT_TOPIC_PUB, \"CMD_SFN ignored: delay too short for time sync.\");\n                rgbled_set_all(CRGB::Red); // Visual error indication\n                delay(3000);\n                if (node_status.get_state() == NodeState::IDLE)\n                    rgbled_set_by_state(NodeState::IDLE);\n            }\n            else\n            {\n                uint64_t now_unix_ms = Time.get_time();\n                uint64_t now_unix_ms_rounded = (now_unix_ms / 1000) * 1000; // Round down to nearest second\n                sensing_scheduled_start_ms = now_unix_ms_rounded + (uint64_t)delay_sec * 1000;\n                sensing_scheduled_end_ms = sensing_scheduled_start_ms + (uint64_t)duration * 1000;\n                sensing_rate_hz = freq;\n                sensing_duration_s = duration;\n\n                parsed_freq = freq;    // global variable at config.hpp\n                parsed_duration = duration; // global variable at config.hpp\n\n                node_status.node_flags.sensing_requested = true;\n                node_status.node_flags.sensing_scheduled = true;\n\n                CalendarTime start_ct = calendar_from_unix_milliseconds(sensing_scheduled_start_ms);\n\n                char buf[128];\n                snprintf(buf, sizeof(buf),\n                         \"[MQTT] CMD_SFN: Sensing scheduled at %04d-%02d-%02d %02d:%02d:%02d | Freq = %d Hz, Duration = %d s\",\n                         start_ct.year, start_ct.month, start_ct.day,\n                         start_ct.hour, start_ct.minute, start_ct.second,\n                         sensing_rate_hz, sensing_duration_s);\n                Serial.println(buf);\n\n                mqtt_client.publish(MQTT_TOPIC_PUB, \"CMD_SFN: Sensing successfully scheduled.\");\n            }\n        }\n        else\n        {\n            Serial.println(\"[MQTT] CMD_SFN format error.\");\n            mqtt_client.publish(MQTT_TOPIC_PUB, \"CMD_SFN ignored: invalid format.\");\n            rgbled_set_all(CRGB::Red);\n            delay(3000);\n            if (node_status.get_state() == NodeState::IDLE)\n                rgbled_set_by_state(NodeState::IDLE);\n        }\n    }\n    else if (msg_str.startsWith(\"CMD_SENSING_\"))\n    {\n        node_status.node_flags.time_rf_required = true;\n\n        strncpy(cmd_sensing_raw, message, sizeof(cmd_sensing_raw) - 1);\n        cmd_sensing_raw[sizeof(cmd_sensing_raw) - 1] = '\\0';\n        node_status.node_flags.sensing_requested = true;\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_SENSING received.\");\n\n        int y, mo, d, h, mi, s;\n        int rate, dur;\n        int matched = sscanf(message,\n                             \"CMD_SENSING_%d-%d-%d_%d:%d:%d_%dHz_%ds\",\n                             &amp;y, &amp;mo, &amp;d, &amp;h, &amp;mi, &amp;s, &amp;rate, &amp;dur);\n        int ms_value = 0;\n\n        if (matched == 8)\n        {\n            CalendarTime ParseTime;\n            ParseTime.year = y;\n            ParseTime.month = mo;\n            ParseTime.day = d;\n            ParseTime.hour = h;\n            ParseTime.minute = mi;\n            ParseTime.second = s;\n            ParseTime.ms = 0;\n\n            parsed_freq = rate;    // global variable at config.hpp\n            parsed_duration = dur; // global variable at config.hpp\n\n            uint64_t now_unix_ms = Time.get_time();\n            uint64_t parsed_temp_sensing_start_ms = unix_from_calendar_milliseconds(ParseTime);\n\n            if (now_unix_ms &gt; parsed_temp_sensing_start_ms)\n            {\n                Serial.println(\"[MQTT] Sensing start time is in the past, ignoring command.\");\n                node_status.node_flags.sensing_requested = false;\n                node_status.node_flags.sensing_scheduled = false;\n\n                // feedback to the mqtt broker\n                mqtt_client.publish(MQTT_TOPIC_PUB, \"Sensing command ignored: start time is in the past!\");\n\n                rgbled_set_all(CRGB::Red); // Set LED to red to indicate error\n                delay(3000);               // Wait for 2 seconds to indicate error\n                if (node_status.get_state() == NodeState::IDLE)\n                {\n                    rgbled_set_by_state(NodeState::IDLE); // Reset LED to IDLE state\n                }\n            }\n            else if (parsed_temp_sensing_start_ms &lt; now_unix_ms + TIME_SYNC_RESERVED_TIME)\n            {\n                Serial.println(\"[ERROR] Not enough time for time synchronization, must larger than TIME_SYNC_RESERVED_TIME (by default 60 seconds), ignoring command.\");\n                node_status.node_flags.sensing_requested = false;\n                node_status.node_flags.sensing_scheduled = false;\n\n                // feedback to the mqtt broker\n                mqtt_client.publish(MQTT_TOPIC_PUB, \"Sensing command ignored: not enough time for time synchronization!\");\n\n                rgbled_set_all(CRGB::Red); // Set LED to red to indicate error\n                delay(3000);               // Wait for 2 seconds to indicate error\n                if (node_status.get_state() == NodeState::IDLE)\n                {\n                    rgbled_set_by_state(NodeState::IDLE); // Reset LED to IDLE state\n                }\n            }\n            else\n            {\n                Serial.println(\"[MQTT] Scheduling sensing...\");\n                sensing_scheduled_start_ms = parsed_temp_sensing_start_ms;\n                sensing_scheduled_end_ms = sensing_scheduled_start_ms + (parsed_duration * 1000);\n                sensing_rate_hz = parsed_freq;\n                sensing_duration_s = parsed_duration;\n\n                node_status.node_flags.sensing_scheduled = true;\n\n                char buf[128];\n                snprintf(buf, sizeof(buf), \"[MQTT] Sensing scheduled, sampling at %d Hz for %d seconds, starting at %04d-%02d-%02d %02d:%02d:%02d\",\n                         sensing_rate_hz, sensing_duration_s,\n                         ParseTime.year, ParseTime.month, ParseTime.day,\n                         ParseTime.hour, ParseTime.minute, ParseTime.second);\n                Serial.println(buf);\n            }\n        }\n        else\n        {\n            Serial.println(\"[MQTT] Failed to parse CMD_SENSING command.\");\n            node_status.node_flags.sensing_requested = false;\n        }\n    }\n    else if (msg_str.startsWith(\"CMD_RETRIEVAL_\"))\n    {\n        const char *filename_part = message + 14;\n        snprintf(retrieval_filename, sizeof(retrieval_filename), \"/%s.txt\", filename_part);\n        node_status.node_flags.data_retrieval_requested = true;\n        node_status.node_flags.data_retrieval_sent = false; // Reset sent flag for new retrieval\n\n        Serial.print(\"[COMMUNICATION] &lt;CMD&gt; CMD_RETRIEVAL received: \");\n        Serial.println(retrieval_filename);\n\n        // switch to COMMUNICATING state\n        node_status.set_state(NodeState::WIFI_COMMUNICATING);\n        rgbled_set_all(CRGB::Blue); // Set LED to blue during data retrieval\n    }\n    else if (msg_str == \"CMD_REBOOT\")\n    {\n        node_status.node_flags.reboot_required_gateway = true;\n        node_status.node_flags.reboot_required_leafnode = true;\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_REBOOT received.\");\n    }\n    else if (msg_str == \"CMD_GATEWAY_REBOOT\")\n    {\n        node_status.node_flags.reboot_required_gateway = true;\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_GATEWAY_REBOOT received.\");\n    }\n    else if (msg_str == \"CMD_LEAFNODE_REBOOT\")\n    {\n        node_status.node_flags.reboot_required_leafnode = true;\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; CMD_LEAFNODE_REBOOT received.\");\n    }\n    else\n    {\n        Serial.println(\"[COMMUNICATION] &lt;CMD&gt; Unknown command.\");\n    }\n}\n</code></pre> <p>As shown in the code, we currently define several command types:</p> <ol> <li>Reboot</li> <li>NTP synchronization</li> <li>RF synchronization</li> <li>Sensing command</li> <li>Data retrieval command</li> </ol>"},{"location":"SOFTWARE/COMMAND-FEEDBACK/command/#rf-part","title":"RF Part","text":"<p>We use <code>rf_cmd.hpp</code> and <code>rf_cmd.cpp</code> to handle RF commands. Similar to the MQTT part, we define a set of commands that can be sent to the leaf nodes. The leaf nodes will parse these commands and execute the corresponding actions.</p> <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n#include \"config.hpp\"\n#include \"nodestate.hpp\"\n#include \"rf.hpp\"\n#include \"rgbled.hpp\"\n#include \"wifi.hpp\"\n#include \"mqtt.hpp\"\n#include \"time.hpp\"\n\n#define RF_CMD_RETRY        3     \n#define RF_CMD_WAIT_MS      100   \n\n// For GATEWAY\nvoid rf_command(const char *cmd);\nvoid send_command_with_retry(const char *cmd);\n\n// For LEAFNODE\nvoid rf_handle();\n</code></pre> <pre><code>#include \"rf_cmd.hpp\"\n\nvoid rf_command(const char *cmd)\n{\n    RFMessage msg;\n    msg.from_id = NODE_ID;\n    strncpy(msg.payload, cmd, sizeof(msg.payload));\n\n    for (uint8_t target_id = 1; target_id &lt;= NUM_NODES; ++target_id)\n    {\n        msg.to_id = target_id;\n\n        Serial.print(\"[GATEWAY] Sending RF Command to Node \");\n        Serial.print(target_id);\n        Serial.print(\": \");\n        Serial.println(msg.payload);\n\n        rf_stop_listening();\n        bool success = rf_send(msg.to_id, msg);\n        if (success)\n        {\n            Serial.println(\"[GATEWAY] Command sent successfully.\");\n        }\n        else\n        {\n            Serial.println(\"[GATEWAY] Failed to send command.\");\n        }\n        rf_start_listening();\n    }\n}\n\nvoid send_command_with_retry(const char *cmd)\n{\n    for (int attempt = 0; attempt &lt; RF_CMD_RETRY; ++attempt)\n    {\n        rf_command(cmd);\n        delay(RF_CMD_WAIT_MS);\n    }\n}\n\nvoid rf_handle()\n{\n    RFMessage msg;\n\n    if (rf_receive(msg, 200)) // 200ms timeout\n    {\n        if (msg.to_id != NODE_ID)\n            return;\n\n        Serial.print(\"[RF_COMMUNICATION] Message received from Node \");\n        Serial.print(msg.from_id);\n        Serial.print(\": \");\n        Serial.println(msg.payload);\n\n        // === CMD_REBOOT ===\n        if (strcmp(msg.payload, \"CMD_REBOOT\") == 0)\n        {\n            Serial.println(\"[LEAFNODE] Reboot command received.\");\n            node_status.node_flags.reboot_required_leafnode = true;\n            node_status.set_state(NodeState::BOOT);\n            rgbled_set_by_state(NodeState::BOOT);\n        }\n\n        // === CMD_RF_SYNC ===\n        else if (strcmp(msg.payload, \"CMD_RF_SYNC\") == 0)\n        {\n            Serial.println(\"[LEAFNODE] RF Sync command received.\");\n            node_status.node_flags.time_rf_required = true;\n            node_status.set_state(NodeState::RF_COMMUNICATING);\n            rgbled_set_by_state(NodeState::RF_COMMUNICATING);\n        }\n\n        // === Sensing Schedule Command ===\n        else if (strncmp(msg.payload, \"S_\", 2) == 0)\n        {\n            Serial.println(\"[LEAFNODE] Sensing command received.\");\n\n            // Step 1: Extract 12-digit time\n            char datetime[13] = {0};\n            strncpy(datetime, msg.payload + 2, 12);\n\n            // Step 2: Find first and second underscore after time part\n            const char *ptr = msg.payload + 14;\n            const char *first_underscore = strchr(ptr, '_');\n            if (!first_underscore)\n            {\n                Serial.println(\"[LEAFNODE] Invalid sensing command format: missing first underscore.\");\n                return;\n            }\n\n            const char *second_underscore = strchr(first_underscore + 1, '_');\n            if (!second_underscore)\n            {\n                Serial.println(\"[LEAFNODE] Invalid sensing command format: missing second underscore.\");\n                return;\n            }\n\n            // Step 3: Extract substrings for rate and duration\n            char rate_buf[6] = {0};\n            char dur_buf[6] = {0};\n\n            size_t rate_len = second_underscore - (first_underscore + 1);\n            size_t dur_len = strlen(second_underscore + 1);\n\n            if (rate_len &gt;= sizeof(rate_buf) || dur_len &gt;= sizeof(dur_buf))\n            {\n                Serial.println(\"[LEAFNODE] Rate or duration value too long.\");\n                return;\n            }\n\n            strncpy(rate_buf, first_underscore + 1, rate_len);\n            strncpy(dur_buf, second_underscore + 1, dur_len);\n\n            int rate = atoi(rate_buf);\n            int dur = atoi(dur_buf);\n\n            CalendarTime SensingSchedule;\n            SensingSchedule = YYMMDDHHMMSS2Calendar(datetime);\n\n            parsed_freq = rate;\n            sensing_rate_hz = parsed_freq;\n            parsed_duration = dur;\n            sensing_duration_s = parsed_duration;\n\n            sensing_scheduled_start_ms = unix_from_calendar_milliseconds(SensingSchedule);\n            sensing_scheduled_end_ms = sensing_scheduled_start_ms + dur * 1000;\n\n            node_status.node_flags.sensing_scheduled = true; // very important!\n\n            // Debug print\n            Serial.print(\"[LEAFNODE] Parsed Time: \");\n            Serial.print(SensingSchedule.year);\n            Serial.print(\"-\");\n            Serial.print(SensingSchedule.month);\n            Serial.print(\"-\");\n            Serial.print(SensingSchedule.day);\n            Serial.print(\" \");\n            Serial.print(SensingSchedule.hour);\n            Serial.print(\":\");\n            Serial.print(SensingSchedule.minute);\n            Serial.print(\":\");\n            Serial.println(SensingSchedule.second);\n\n            Serial.print(\"[LEAFNODE] Parsed Rate = \");\n            Serial.print(parsed_freq);\n            Serial.print(\" Hz, Duration = \");\n            Serial.print(parsed_duration);\n            Serial.println(\" sec\");\n\n            Serial.print(\"[LEAFNODE] Scheduled Start Time (ms): \");\n            Serial.println(sensing_scheduled_start_ms);\n\n            Serial.print(\"[LEAFNODE] Scheduled Sampling Rate: \");\n            Serial.print(sensing_rate_hz);\n\n            Serial.print(\" Hz, Duration: \");\n            Serial.print(sensing_duration_s);\n            Serial.println(\" sec\");\n        }\n        // === Unknown Command ===\n        else\n        {\n            Serial.println(\"[RF_COMMUNICATION] Unknown command.\");\n        }\n    }\n}\n</code></pre>"},{"location":"SOFTWARE/COMMAND-FEEDBACK/feedback/","title":"feedback","text":"<p>In this project, the feedback system is implemented using an RGB LED strip. Following is the relevant code:</p> <p>rgbled.hpp</p> <pre><code>#pragma once\n\n#include &lt;Arduino.h&gt;\n#include &lt;FastLED.h&gt;\n#include \"nodestate.hpp\"\n\n#define NUM_LEDS 4\n#define LED_PIN 7\n\nextern CRGB leds[NUM_LEDS];\n\nvoid rgbled_init();\nvoid rgbled_set_all(CRGB color);\nvoid rgbled_clear();\nvoid rgbled_set_by_state(NodeState state);\n</code></pre> <p>rgbled.cpp</p> <pre><code>#include \"rgbled.hpp\"\n\nCRGB leds[NUM_LEDS];\n\nvoid rgbled_init()\n{\n    FastLED.addLeds&lt;WS2812B, LED_PIN, GRB&gt;(leds, NUM_LEDS);\n    FastLED.setBrightness(50);\n\n    leds[0] = CRGB::Red;\n    leds[1] = CRGB::Yellow;\n    leds[2] = CRGB::Green;\n    leds[3] = CRGB::Blue;\n    FastLED.show();\n\n    Serial.println(\"[INIT] &lt;RGB LED&gt; Initialized with default colors.\");\n}\n\nvoid rgbled_set_all(CRGB color)\n{\n    for (int i = 0; i &lt; NUM_LEDS; ++i)\n    {\n        leds[i] = color;\n    }\n    FastLED.show();\n}\n\nvoid rgbled_clear()\n{\n    rgbled_set_all(CRGB::Black);\n}\n\nvoid rgbled_set_by_state(NodeState state)\n{\n    CRGB color;\n\n    switch (state)\n    {\n    case NodeState::BOOT:                color = CRGB(0xFFFFFF); break; // White\n    case NodeState::IDLE:                color = CRGB(0x008000); break; // Green\n    case NodeState::PREPARING:           color = CRGB(0xFFFF00); break; // Yellow\n    case NodeState::SAMPLING:            color = CRGB(0x800080); break; // Purple\n    case NodeState::RF_COMMUNICATING:    color = CRGB(0x00FFFF); break; // Cyan\n    case NodeState::WIFI_COMMUNICATING:  color = CRGB(0x0000FF); break; // Blue\n    case NodeState::ERROR:               color = CRGB(0xFF0000); break; // Red\n    default:                             color = CRGB::Black;    break;\n    }\n\n    rgbled_set_all(color);\n}\n</code></pre> <p>The RGB LED initialization occurs after the sensor is powered on. During operation, you can call the <code>rgbled_set_all(CRGB color)</code> function to set the color of all LEDs, or call the <code>rgbled_clear()</code> function to turn off all LEDs. In this project, to cooperate with the node state machine, the <code>rgbled_set_by_state(NodeState state)</code> function is used to set the LED color based on the current node state. </p>"},{"location":"SOFTWARE/COMMUNICATION/mqtt/","title":"MQTT - Message Queuing Telemetry Transport Protocol","text":"<p>Message Queuing Telemetry Transport (MQTT) is a lightweight messaging protocol designed for low-bandwidth, high-latency, or unreliable networks. It is commonly used for communication between Internet of Things (IoT) devices. In simple terms, the MQTT server acts as an intermediary, relaying messages between users and devices. This section will cover how to connect an Arduino to an MQTT server for remote control and monitoring.</p> <p>Following are the MQTT-related code files used in this project:</p> <p>mqtt.hpp <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n#include \"config.hpp\"\n#include \"nodestate.hpp\"\n#include &lt;WiFiS3.h&gt;\n#include &lt;PubSubClient.h&gt;\n#include \"mqtt_cmd.hpp\"\n\n\n// Create a WiFi client and wrap it in PubSubClient\n\nextern WiFiClient wifi_client;\nextern PubSubClient mqtt_client;\n\n// === Retrieval Filename\nextern char retrieval_filename[32];\n\n// to slow down MQTT loop\nbool should_run_mqtt_loop();\n\n// Initialize and connect to MQTT broker\nvoid mqtt_setup();\n\n// Call this in loop() to keep MQTT alive\nvoid mqtt_loop();\n\n// Publish a test message to broker\nvoid mqtt_publish_test();\n</code></pre></p> <p>mqtt.cpp <pre><code>#include \"mqtt.hpp\"\n\n// Create a WiFi client and wrap it in PubSubClient\nWiFiClient wifi_client;\nPubSubClient mqtt_client(wifi_client);\nchar retrieval_filename[32];\n\n// to slow down MQTT loop\nbool should_run_mqtt_loop()\n{\n  static unsigned long last = 0;\n  unsigned long now = millis();\n  if (now - last &gt;= 500)\n  {\n    last = now;\n    return true;\n  }\n  return false;\n}\n\n// Connect to MQTT broker\nvoid mqtt_setup()\n{\n  mqtt_client.setServer(MQTT_BROKER_ADDRESS, MQTT_BROKER_PORT);\n  mqtt_client.setCallback(mqtt_callback);\n\n  Serial.println(\"[INIT] &lt;MQTT&gt; Connecting to broker... \");\n  while (!mqtt_client.connected())\n  {\n    if (mqtt_client.connect(MQTT_CLIENT_ID, MQTT_USERNAME, MQTT_PASSWORD))\n    {\n      Serial.println(\"[INIT] &lt;MQTT&gt; Connected.\");\n      mqtt_client.subscribe(MQTT_TOPIC_SUB);\n      node_status.node_flags.mqtt_connected = true;\n    }\n    else\n    {\n      Serial.print(\"[INIT] &lt;MQTT&gt; Failed, Return Code = \");\n      Serial.print(mqtt_client.state());\n      Serial.println(\" -&gt; retrying in 2 sec...\");\n      delay(2000);\n    }\n  }\n}\n\n// Keep MQTT connection alive\nvoid mqtt_loop()\n{\n  if (!mqtt_client.connected())\n  {\n    Serial.println(\"[COMMUNICATION] &lt;MQTT&gt; Reconnecting...\");\n    mqtt_setup();\n  }\n  mqtt_client.loop();\n}\n\n// Publish a test message\nvoid mqtt_publish_test()\n{\n  if (mqtt_client.connected())\n  {\n    mqtt_client.publish(MQTT_TOPIC_PUB, \"Hello from Arduino MQTT!\");\n    Serial.println(\"[TEST] &lt;MQTT&gt; Test message published.\");\n  }\n}\n</code></pre></p> <p>Note</p> <p>As shown in the code above, the MQTT part mainly consists of several key components including initialization, loop, message publishing, and callback functions. The callback part is explained in detail in the command and feedback section.</p>"},{"location":"SOFTWARE/COMMUNICATION/mqtt/#mqtt-setup","title":"MQTT Setup","text":"<p>As shown in the function <code>mqtt_setup()</code>, MQTT initialization mainly involves setting the server address and port, setting the callback function, and attempting to connect to the MQTT server. If the connection is successful, it subscribes to the specified topic. The relevant macros are defined in <code>config.hpp</code>.</p>"},{"location":"SOFTWARE/COMMUNICATION/mqtt/#mqtt-loop","title":"MQTT Loop","text":"<p>As shown in the function <code>mqtt_loop()</code>, the MQTT loop mainly checks the connection status. If disconnected, it attempts to reconnect. Each time <code>mqtt_loop()</code> is called, it sends a heartbeat packet to the MQTT server to keep the connection alive.</p>"},{"location":"SOFTWARE/COMMUNICATION/mqtt/#mqtt-publish-test","title":"MQTT Publish Test","text":"<p>As shown in the function <code>mqtt_publish_test()</code>, based on the Arduino library, when the MQTT connection is established, calling the function <code>mqtt_client.publish()</code> can publish messages to the specified topic. Here we publish a simple test message, which is the basis for data upload. Note that each time a message is sent, there is a limit on its size. For large data volumes, it may need to be sent in segments or use other methods.</p>"},{"location":"SOFTWARE/COMMUNICATION/mqtt/#mqtt-callback","title":"MQTT Callback","text":"<p>As shown in the function <code>mqtt_callback()</code>, when a message is received on the subscribed topic, this callback function is invoked. The function parses the message content and executes corresponding actions based on different commands. Typically, if the corresponding operation is time-consuming, we set a flag or state machine in the callback function to handle it in the main loop. In the main loop, specific operations are executed based on the corresponding state and flags. Here, we mainly implement remote control based on MQTT callbacks.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/","title":"RADIO FREQUENCY COMMUNICATION","text":"<p>RF communication refers to the technology of transmitting information through radio waves. It is widely used in radio, television, mobile phones, satellite communications and other fields. The basic principle of RF communication is to modulate information onto RF signals and transmit and receive them through antennas. This project uses nRF24L01 wireless module for RF communication.</p> <p>Tip</p> <p>Just like the MQTT command communication based on WiFi, we will introduce the specific details in the command and feedback section. Here, we will first introduce the basic communication functions of the nRF24L01 wireless module.</p> <p>The following is the relevant code implementation for the nRF24L01 wireless module:</p> <p>rf.hpp</p> <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n#include &lt;RF24.h&gt;\n#include \"config.hpp\"\n\n#define RF_CHANNEL 108\n#define RF_PIPE_BASE 0xF0F0F0F000LL\n\nstruct RFMessage\n{\n    uint8_t from_id;\n    uint8_t to_id;\n    char payload[22];       \n    uint64_t timestamp_ms; \n};\n\nextern bool node_online[NUM_NODES + 1]; \n\nbool rf_init();\nbool rf_send(uint8_t to_id, const RFMessage &amp;msg, bool require_ack = false);\nbool rf_receive(RFMessage &amp;msg, unsigned long timeout_ms);\nbool rf_send_then_receive(const RFMessage &amp;msg, uint8_t to_id, unsigned long timeout_ms, uint8_t retries);\n\nvoid rf_stop_listening();\nvoid rf_start_listening();\nvoid rf_set_rx_address(uint8_t id);\nString rf_format_address(uint16_t node_id);\n\nvoid rf_check_node_status();  // Gateway and Leaf share this\n// void rf_sync_log_number();    // Gateway only\n</code></pre> <p>rf.cpp</p> <pre><code>#include \"rf.hpp\"\n#include &lt;SPI.h&gt;\n#include \"logging.hpp\"\n\nRF24 radio(9, 8);\n\nbool node_online[NUM_NODES + 1] = {false}; // Default all to offline\n\nString rf_format_address(uint16_t node_id)\n{\n    char buf[6];\n    snprintf(buf, sizeof(buf), \"N%03d\", node_id);\n    return String(buf);\n}\n\nvoid rf_set_rx_address(uint8_t id)\n{\n    uint64_t address = RF_PIPE_BASE | id;\n    radio.openReadingPipe(1, address);\n    radio.setAutoAck(true);\n}\n\nbool rf_init()\n{\n    if (!radio.begin())\n    {\n        Serial.println(\"[INIT] &lt;RF&gt; Initialization failed.\");\n        return false;\n    }\n\n    radio.setPALevel(RF24_PA_HIGH);\n    radio.setDataRate(RF24_250KBPS); // Use 250kbps for better range and reliability\n    radio.setChannel(RF_CHANNEL);\n    radio.setRetries(5, 15);\n    radio.enableDynamicPayloads();\n    radio.setCRCLength(RF24_CRC_16);\n\n    // Set RX address to this node's own ID so it can receive messages addressed to itself\n    rf_set_rx_address(NODE_ID);\n    radio.startListening();\n\n    Serial.print(\"[INIT] &lt;RF&gt; Initialized. Listening on \");\n    Serial.println(rf_format_address(NODE_ID));\n    return true;\n}\n\nvoid rf_stop_listening() { radio.stopListening(); }\nvoid rf_start_listening() { radio.startListening(); }\n\nbool rf_send(uint8_t to_id, const RFMessage &amp;msg, bool require_ack)\n{\n    uint64_t tx_address = RF_PIPE_BASE | to_id;\n    radio.openWritingPipe(tx_address);\n    return radio.write(&amp;msg, sizeof(RFMessage), require_ack);\n}\n\nbool rf_receive(RFMessage &amp;msg, unsigned long timeout_ms)\n{\n    unsigned long start_time = millis();\n    while (millis() - start_time &lt; timeout_ms)\n    {\n        if (radio.available())\n        {\n            radio.read(&amp;msg, sizeof(RFMessage));\n            return true;\n        }\n    }\n    return false;\n}\n\nbool rf_send_then_receive(const RFMessage &amp;msg, uint8_t to_id, unsigned long timeout_ms, uint8_t retries)\n{\n    for (uint8_t attempt = 0; attempt &lt; retries; ++attempt)\n    {\n        rf_stop_listening();\n        bool sent = rf_send(to_id, msg);\n        rf_start_listening();\n\n        if (!sent)\n        {\n            Serial.print(\"[RF] Send failed (attempt \");\n            Serial.print(attempt + 1);\n            Serial.println(\")\");\n            continue;\n        }\n\n        RFMessage response;\n        if (rf_receive(response, timeout_ms) &amp;&amp; response.to_id == NODE_ID)\n            return true;\n\n        Serial.print(\"[RF] No response received (attempt \");\n        Serial.print(attempt + 1);\n        Serial.println(\")\");\n    }\n    return false;\n}\n\nvoid rf_check_node_status()\n{\n#ifdef GATEWAY\n    delay(2000); // Allow time for radio to stabilize\n    load_log_number();\n    Serial.println(\"[RF] Checking node status and syncing LOG_NUMBER...\");\n\n    const unsigned long timeout_ms = 200;\n\n    for (uint8_t node_id = 1; node_id &lt;= NUM_NODES; ++node_id)\n    {\n        if (node_id == NODE_ID)\n            continue;\n\n        // Prepare LOG message\n        RFMessage msg;\n        msg.from_id = NODE_ID;\n        msg.to_id = node_id;\n        snprintf(msg.payload, sizeof(msg.payload), \"LOG %d\", log_number);\n        msg.timestamp_ms = millis();\n\n        rf_stop_listening();\n        rf_send(node_id, msg, false);\n        rf_start_listening();\n\n        Serial.print(\"[GATEWAY] Sent LOG_NUMBER \");\n        Serial.print(log_number);\n        Serial.print(\" to Node \");\n        Serial.println(node_id);\n\n        // Wait for PONG reply with confirmation\n        bool online = false;\n        RFMessage reply;\n        if (rf_receive(reply, timeout_ms) &amp;&amp;\n            reply.to_id == NODE_ID &amp;&amp;\n            reply.from_id == node_id &amp;&amp;\n            strncmp(reply.payload, \"PONG\", 4) == 0)\n        {\n            int confirmed_log = 0;\n            sscanf(reply.payload, \"PONG %d\", &amp;confirmed_log);\n            Serial.print(\"  - Node \");\n            Serial.print(node_id);\n            Serial.print(\" is ONLINE. Confirmed LOG_NUMBER = \");\n            Serial.println(confirmed_log);\n            online = true;\n        }\n        else\n        {\n            Serial.print(\"  - Node \");\n            Serial.print(node_id);\n            Serial.println(\" is OFFLINE or unresponsive.\");\n        }\n\n        node_online[node_id] = online;\n    }\n\n#endif\n\n#ifdef LEAFNODE\n    Serial.println(\"[LEAFNODE] Waiting for LOG_NUMBER from GATEWAY...\");\n\n    while (true)\n    {\n        RFMessage msg;\n        if (rf_receive(msg, 100))\n        {\n            if (strncmp(msg.payload, \"LOG\", 3) == 0 &amp;&amp; msg.to_id == NODE_ID)\n            {\n                int received_log = 0;\n                sscanf(msg.payload, \"LOG %d\", &amp;received_log);\n                log_number = received_log;\n                save_log_number();\n\n                Serial.print(\"[LEAFNODE] Received and saved LOG_NUMBER = \");\n                Serial.println(log_number);\n\n                // Respond with PONG and confirmed log number\n                RFMessage reply;\n                reply.from_id = NODE_ID;\n                reply.to_id = msg.from_id;\n                snprintf(reply.payload, sizeof(reply.payload), \"PONG %d\", log_number);\n                reply.timestamp_ms = millis();\n\n                rf_stop_listening();\n                rf_send(msg.from_id, reply, false);\n                rf_start_listening();\n\n                Serial.println(\"[LEAFNODE] PONG with LOG_NUMBER sent.\");\n                break; // Exit after one successful exchange\n            }\n        }\n    }\n#endif\n}\n</code></pre>"},{"location":"SOFTWARE/COMMUNICATION/rf/#key-functions","title":"Key Functions","text":"Function Name Description <code>rf_init()</code> Initializes the nRF24L01 module, sets the channel, data rate, and other parameters, and begins listening. <code>rf_send(uint8_t to_id, const RFMessage &amp;msg, bool require_ack = false)</code> Sends an RFMessage to the specified node ID, with optional acknowledgment requirement. <code>rf_receive(RFMessage &amp;msg, unsigned long timeout_ms)</code> Receives an RFMessage until a timeout occurs or a message is received. <code>rf_send_then_receive(const RFMessage &amp;msg, uint8_t to_id, unsigned long timeout_ms, uint8_t retries)</code> Sends a message and waits for a response, with a configurable retry mechanism. <code>rf_stop_listening()</code> Stops listening and switches to transmission mode. <code>rf_start_listening()</code> Starts listening and switches to receiving mode. <code>rf_set_rx_address(uint8_t id)</code> Sets the receiving address to listen to messages from a specific node ID. <code>rf_format_address(uint16_t node_id)</code> Formats the node ID into a human-readable string for logging/debugging."},{"location":"SOFTWARE/COMMUNICATION/rf/#rfmessage-structure","title":"RFMessage Structure","text":"<p>The <code>RFMessage</code> structure defines the format of messages exchanged over RF communication. It includes the following fields:</p> <ul> <li><code>from_id</code>: The sender's node ID.</li> <li><code>to_id</code>: The receiver's node ID.</li> <li><code>payload</code>: The actual data payload of the message (max 22 bytes).</li> <li><code>timestamp_ms</code>: The timestamp (in milliseconds) when the message is sent.</li> </ul>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_init-function","title":"rf_init() Function","text":"<p>The <code>rf_init()</code> function initializes the nRF24L01 module. It attempts to start the RF module and returns <code>false</code> if initialization fails. If successful, it sets transmission power level, data rate, channel, retry count, and enables features such as dynamic payloads and CRC checking. It then calls <code>rf_set_rx_address(NODE_ID)</code> to set the current node\u2019s receiving address and starts listening. If successful, the function prints the current node\u2019s address and returns <code>true</code>.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_set_rx_address-function","title":"rf_set_rx_address() Function","text":"<p>The <code>rf_set_rx_address(uint8_t id)</code> function sets the receiving address for the nRF24L01 module. It combines the input node ID with a predefined base address (<code>RF_PIPE_BASE</code>) to form a full address. It then calls <code>radio.openReadingPipe(1, address)</code> to open a reading pipe and enables auto-acknowledgment.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_format_address-function","title":"rf_format_address() Function","text":"<p>The <code>rf_format_address(uint16_t node_id)</code> function formats a node ID into a readable string using <code>snprintf</code>, producing a string in the format \"Nxxx\" (e.g., N001, N100). Useful for printing and debugging.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_send-function","title":"rf_send() Function","text":"<p>The <code>rf_send(uint8_t to_id, const RFMessage &amp;msg, bool require_ack)</code> function sends an RFMessage to the specified <code>to_id</code>. It generates the target write pipe address and transmits the message to that address. It returns <code>true</code> on success, <code>false</code> on failure. If <code>require_ack</code> is true, the function waits for an acknowledgment from the receiver.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_receive-function","title":"rf_receive() Function","text":"<p>The <code>rf_receive(RFMessage &amp;msg, unsigned long timeout_ms)</code> function attempts to receive an RFMessage within the given timeout. It continuously checks if data is available and reads the message into <code>msg</code> upon success. Returns <code>true</code> if a message is received before timeout, otherwise returns <code>false</code>.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_send_then_receive-function","title":"rf_send_then_receive() Function","text":"<p>The <code>rf_send_then_receive(const RFMessage &amp;msg, uint8_t to_id, unsigned long timeout_ms, uint8_t retries)</code> function sends a message and waits for a response. It attempts to send the message up to <code>retries</code> times. After each send, it switches to listening mode and waits for a valid response. If a response is received and its <code>to_id</code> matches the current node\u2019s ID, it returns <code>true</code>. Returns <code>false</code> if all attempts fail.</p>"},{"location":"SOFTWARE/COMMUNICATION/rf/#rf_stop_listening-and-rf_start_listening-functions","title":"rf_stop_listening() and rf_start_listening() Functions","text":"<ul> <li> <p><code>rf_stop_listening()</code> stops the nRF24L01 from listening mode and switches to transmit mode using <code>radio.stopListening()</code>.</p> </li> <li> <p><code>rf_start_listening()</code> starts listening mode using <code>radio.startListening()</code> to receive incoming messages.</p> </li> </ul>"},{"location":"SOFTWARE/COMMUNICATION/wifi/","title":"WIFI","text":"<p>The microcontroller used in this project is the Arduino Uno R4 Wifi, which has an onboard ESP32 chip that supports both WiFi and Bluetooth functionalities. Using the official Arduino WiFi library, WiFiS3, we can easily connect to a WiFi network. In this project, WiFi serves as the physical infrastructure for IoT communication.</p> <p>wifi.hpp</p> <pre><code>#pragma once\n\n#include \"config.hpp\"\n\n// Function declaration\nvoid connect_to_wifi();\n</code></pre> <p>wifi.cpp</p> <pre><code>#include \"wifi.hpp\"\n#include &lt;WiFiS3.h&gt;\n\nvoid connect_to_wifi()\n{\n    Serial.print(\"[INIT] &lt;WIFI&gt; Connecting to WiFi: \");\n    Serial.println(WIFI_SSID);\n\n    int status = WL_IDLE_STATUS;\n\n    while (status != WL_CONNECTED)\n    {\n        status = WiFi.begin(WIFI_SSID, WIFI_PASSWORD);\n        delay(1000);\n    }\n\n    Serial.println(\"[INIT] &lt;WIFI&gt; Connected.\");\n    Serial.print(\"[INIT] &lt;WIFI&gt; IP address: \");\n    Serial.println(WiFi.localIP());\n}\n</code></pre> <p>As shown in the code, you can complete the WiFi connection by calling the <code>connect_to_wifi()</code> function at an appropriate place in your main program.</p>"},{"location":"SOFTWARE/CONFIGURATION/configuration/","title":"CONFIGURATION","text":"<p>To facilitate the configuration of the software, we provide a configuration file that can be easily modified. This file is located in the <code>config</code> directory of the software installation.</p> <p>Tip</p> <p>Note that we also place some global variables related to sensing control in the configuration file for easy reference and modification in other files.</p> <p>GATEWAY NODE EXAMPLE</p> <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n\n/* Node Information */\n#define GATEWAY          // for main node\n// #define LEAFNODE        // for sensor node\n\n#define NODE_ID 100      // GATEWAY should be 100\n// #define NODE_ID 1 // for LEAFNODE: 1, 2\n// #define NODE_ID 2\n\n#define NUM_NODES 2 // Total number of nodes in the network\n\n/* WiFi Credentials */\n#define WIFI_SSID \"Shaun's Iphone\"\n#define WIFI_PASSWORD \"cshw0918\"\n\n/* MQTT Configurations */\n#define MQTT_CLIENT_ID      \"GATEWAY\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE1\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE2\"\n\n#define MQTT_BROKER_ADDRESS \"8.222.194.160\"\n#define MQTT_BROKER_PORT    1883\n#define MQTT_USERNAME       \"ArduinoNode\"\n#define MQTT_PASSWORD       \"Arduino123\"\n#define MQTT_TOPIC_PUB      \"ArduinoNode/node\"\n#define MQTT_TOPIC_SUB      \"ArduinoNode/server\"\n\n// Sensing Variables \nextern uint64_t sensing_scheduled_start_ms; // Scheduled sensing start time (Unix ms)\nextern uint64_t sensing_scheduled_end_ms;   // Scheduled sensing end time (Unix ms)\nextern uint32_t sensing_rate_hz;            // Sensing rate in Hz\nextern uint32_t sensing_duration_s;         // Sensing duration in seconds\nextern uint32_t default_sensing_rate_hz;   // Default sensing rate in Hz\nextern uint32_t default_sensing_duration_s; // Default sensing duration in seconds\nextern uint16_t parsed_freq;                // Parsed frequency from command\nextern uint16_t parsed_duration;            // Parsed duration from command\nextern float cali_scale_x; // Calibration scale for X-axis\nextern float cali_scale_y; // Calibration scale for Y-axis\nextern float cali_scale_z; // Calibration scale for Z-axis\n\n/* Serial Configurations */\n// #define DATA_PRINTOUT // Enable data printout to Serial\n\n// === Function Declaration ===\nvoid print_node_config();\n</code></pre> <p>LEAFNODE EXAMPLE</p> <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n\n/* Node Information */\n// #define GATEWAY          // for main node\n#define LEAFNODE        // for sensor node\n\n// #define NODE_ID 100      // GATEWAY should be 100\n#define NODE_ID 1 // for LEAFNODE: 1, 2\n// #define NODE_ID 2\n\n#define NUM_NODES 2 // Total number of nodes in the network\n\n/* WiFi Credentials */\n#define WIFI_SSID \"Shaun's Iphone\"\n#define WIFI_PASSWORD \"cshw0918\"\n\n/* MQTT Configurations */\n// #define MQTT_CLIENT_ID      \"GATEWAY\"\n#define MQTT_CLIENT_ID      \"LEAFNODE1\"\n// #define MQTT_CLIENT_ID      \"LEAFNODE2\"\n\n#define MQTT_BROKER_ADDRESS \"8.222.194.160\"\n#define MQTT_BROKER_PORT    1883\n#define MQTT_USERNAME       \"ArduinoNode\"\n#define MQTT_PASSWORD       \"Arduino123\"\n#define MQTT_TOPIC_PUB      \"ArduinoNode/node\"\n#define MQTT_TOPIC_SUB      \"ArduinoNode/server\"\n\n// Sensing Variables \nextern uint64_t sensing_scheduled_start_ms; // Scheduled sensing start time (Unix ms)\nextern uint64_t sensing_scheduled_end_ms;   // Scheduled sensing end time (Unix ms)\nextern uint32_t sensing_rate_hz;            // Sensing rate in Hz\nextern uint32_t sensing_duration_s;         // Sensing duration in seconds\nextern uint32_t default_sensing_rate_hz;   // Default sensing rate in Hz\nextern uint32_t default_sensing_duration_s; // Default sensing duration in seconds\nextern uint16_t parsed_freq;                // Parsed frequency from command\nextern uint16_t parsed_duration;            // Parsed duration from command\nextern float cali_scale_x; // Calibration scale for X-axis\nextern float cali_scale_y; // Calibration scale for Y-axis\nextern float cali_scale_z; // Calibration scale for Z-axis\n\n/* Serial Configurations */\n// #define DATA_PRINTOUT // Enable data printout to Serial\n\n// === Function Declaration ===\nvoid print_node_config();\n</code></pre> <p>As shown in the code snippet above, the configuration file includes node information, WiFi credentials, and MQTT configurations.</p> <p>Apart from the configuration file, there is also a function <code>print_node_config()</code> that can be used to print the current node's configuration information to the serial console. It is defined in the <code>config.cpp</code> file, and you can call it in the <code>setup()</code> function to display the current node's configuration.</p> <pre><code>#include \"config.hpp\"\n\nuint64_t sensing_scheduled_start_ms = 0;\nuint64_t sensing_scheduled_end_ms = 0;\nuint32_t default_sensing_rate_hz = 200;\nuint32_t default_sensing_duration_s = 300;\nuint32_t sensing_rate_hz = default_sensing_rate_hz ;\nuint32_t sensing_duration_s = default_sensing_duration_s;\nuint16_t parsed_freq = 0;\nuint16_t parsed_duration = 0;\n\nfloat cali_scale_x = 1.0f; // Calibration scale for X-axis\nfloat cali_scale_y = 1.0f; // Calibration scale for Y-axis\nfloat cali_scale_z = 1.0f; // Calibration scale for Z-axis\n\nvoid print_node_config()\n{\n  Serial.println(\"=== Node Configuration Info ===\");\n\n#ifdef GATEWAY\n  Serial.println(\"Node Type     : GATEWAY\");\n#endif\n#ifdef LEAFNODE\n  Serial.println(\"Node Type     : LEAFNODE\");\n#endif\n\n  Serial.print(\"Node ID       : \");\n  Serial.println(NODE_ID);\n\n  Serial.print(\"Total Nodes   : \");\n  Serial.println(NUM_NODES);\n\n  Serial.println(\"------ WiFi ------\");\n  Serial.print(\"SSID          : \");\n  Serial.println(WIFI_SSID);\n  Serial.print(\"Password      : \");\n  Serial.println(WIFI_PASSWORD);\n\n  Serial.println(\"------ MQTT ------\");\n  Serial.print(\"Client ID     : \");\n  Serial.println(MQTT_CLIENT_ID);\n  Serial.print(\"Broker Addr   : \");\n  Serial.println(MQTT_BROKER_ADDRESS);\n  Serial.print(\"Broker Port   : \");\n  Serial.println(MQTT_BROKER_PORT);\n  Serial.print(\"Username      : \");\n  Serial.println(MQTT_USERNAME);\n  Serial.print(\"Password      : \");\n  Serial.println(MQTT_PASSWORD);\n  Serial.print(\"Pub Topic     : \");\n  Serial.println(MQTT_TOPIC_PUB);\n  Serial.print(\"Sub Topic     : \");\n  Serial.println(MQTT_TOPIC_SUB);\n\n  Serial.println(\"===============================\");\n}\n</code></pre>"},{"location":"SOFTWARE/CONFIGURATION/configuration/#node-modes","title":"Node Modes","text":"<p>For wireless sensor networks, there are two concepts: gateway node (GATEWAY) and sensor node (LEAFNODE). Correspondingly, we have two macros to define the node type, enabling conditional compilation in the code.</p> <p>Tip</p> <p>In the configuration file, the two macros <code>GATEWAY</code> and <code>LEAFNODE</code> are mutually exclusive. You can only choose one to define your node type.</p>"},{"location":"SOFTWARE/CONFIGURATION/configuration/#node-id","title":"Node ID","text":"<p>Each node has a unique ID, with the gateway node having an ID of 100 (different from the sensor nodes), and the sensor nodes numbered from 1 to <code>NUM_NODES</code>. You can set the current node's ID by modifying the <code>NODE_ID</code> macro.</p>"},{"location":"SOFTWARE/CONFIGURATION/configuration/#wifi-credentials","title":"WiFi Credentials","text":"<p>Each node needs to connect to a WiFi network, so you need to provide the WiFi SSID and password. You can set your WiFi credentials by modifying the <code>WIFI_SSID</code> and <code>WIFI_PASSWORD</code> macros in the configuration file.</p> <p>Warning</p> <p>Due to the limitations of Arduino, it currently does not support connecting to enterprise-level WiFi networks such as campus networks. Please use a home or personal WiFi network. It is recommended to use a mobile hotspot and set <code>WIFI_SSID</code> and <code>WIFI_PASSWORD</code> in the configuration file to the SSID and password of your mobile hotspot.</p>"},{"location":"SOFTWARE/CONFIGURATION/configuration/#mqtt-configurations","title":"MQTT Configurations","text":"<p>Each node needs to connect to an MQTT server, so you need to provide the relevant MQTT configurations. You can modify the following macros in the configuration file:</p> <ul> <li><code>MQTT_CLIENT_ID</code>: Set the MQTT client ID for the current node. The gateway node is set to <code>GATEWAY</code>, and sensor nodes are set to <code>LEAFNODE1</code>, <code>LEAFNODE2</code>, etc.</li> <li><code>MQTT_BROKER_ADDRESS</code>: Set the address of the MQTT broker. The default address in the code can be used.</li> <li><code>MQTT_BROKER_PORT</code>: Set the port of the MQTT broker, typically 1883. This is the default port for MQTT.</li> <li><code>MQTT_USERNAME</code>: Set the username for MQTT authentication. The default username in the code can be used.</li> <li><code>MQTT_PASSWORD</code>: Set the password for MQTT authentication. The default password in the code can be used.</li> <li><code>MQTT_TOPIC_PUB</code>: Set the topic for publishing messages. The default topic in the code can be used.</li> <li><code>MQTT_TOPIC_SUB</code>: Set the topic for subscribing to messages. The default topic in the code can be used.</li> </ul> <p>Warning</p> <p>Please ensure that the node mode, node ID, and MQTT client ID are consistent. Besides, please ensure all other information is correct, as incorrect configurations may lead to connection failures or unexpected behaviors.</p>"},{"location":"SOFTWARE/FRAMEWORK/framework/","title":"Development Framework","text":"<p>Development Framework</p> <p>For simplicity, this project does not use an RTOS but is developed directly based on the basic model of \"initialization\" and \"loop\" of the microcontroller. On this basis, a state machine model is introduced to manage different states. The core of the framework is the <code>main.cpp</code> file, which contains the basic logic for initialization and looping. Functions for sensing, communication, storage, etc., are encapsulated for easy invocation as needed.</p>"},{"location":"SOFTWARE/FRAMEWORK/framework/#part-i-initialization-part","title":"Part I Initialization Part","text":"<p>Initialization is responsible for setting up hardware, configuring peripherals, and initializing various modules. In this project, initialization mainly includes the following aspects:</p> <ul> <li>Hardware configuration: Setting up GPIO, UART, SPI, and other peripheral pins and parameters.</li> <li>Module initialization: Initializing sensors, communication modules (such as Wi-Fi, etc.), storage modules, etc.</li> <li>System settings: Clock synchronization, system parameter configuration, etc.</li> </ul> <pre><code>+=============================+        +=============================+\n|         GATEWAY NODE        |        |          LEAF NODE          |\n+=============================+        +=============================+\n| - Init serial               |        | - Init serial               |\n| - Init RGB LED              |        | - Init RGB LED              |\n| - Init IMU                  |        | - Init IMU                  |\n| - Init SD card              |        | - Init SD card              |\n| - Init RF module            |        | - Init RF module            |\n| - Connect WiFi              |        |                             |\n| - Sync time (NTP)           |        |                             |\n| - Setup MQTT                |        |                             |\n| - RF online check &amp; RTT     |        |                             |\n| - RF time sync              | &lt;====&gt; | - RF time sync              |\n| - Wait for tasks            |        | - Wait for schedule         |\n+-----------------------------+        +-----------------------------+\n</code></pre> <p>Below is a typical startup process serial output example for the gateway node:</p> <p></p> <p>Tip</p> <p>Though each node can be connected to the Internet through Wifi, we only use the gateway node to connect to the Internet in this project for practical considerations. </p>"},{"location":"SOFTWARE/FRAMEWORK/framework/#part-ii-loop-part","title":"Part II Loop Part","text":"<p>The loop part is the core of the program, responsible for continuously executing tasks such as sensing, processing, and communication. In this project, the loop part mainly manages different states through a state machine by monitoring a series of flags. In the loop part, the leaf nodes continuously listen for messages from the gateway node in the IDLE state, parse the received messages, and execute corresponding operations.</p> <pre><code>+===============================================================================================+\n|                                     LOOP START                                                |\n|                                                                                               |\n|  +------+------+-----------+----------+------------------+--------------------+-------+       |\n|  | BOOT | IDLE | PREPARING | SAMPLING | RF_COMMUNICATING | WIFI_COMMUNICATING | ERROR |       |\n|  +------+------+-----------+----------+------------------+--------------------+-------+       |\n|                                                                                               |\n|  \u2192 Check current state \u2192 Execute logic \u2192 Repeat                                               |\n+===============================================================================================+\n</code></pre>"},{"location":"SOFTWARE/FRAMEWORK/framework/#part-iii-background-callbacks","title":"Part III Background Callbacks","text":"<p>The background callbacks refer to functions that are automatically triggered when certain events occur during the program's execution. These callback functions are typically used to handle asynchronous events, such as receiving data, timer timeouts, etc. In this project, they are mainly used to listen for messages from the communication module and process them accordingly.</p> <pre><code>+============================+                           +============================+\n|        FOREGROUND          |                           |        BACKGROUND          |\n|  (Main thread execution)   |                           |   (Interrupts / Callbacks) |\n+============================+                           +============================+\n|                            |                           |                            |\n|  setup():                  |                           |  - RF receive interrupt    |\n|  - Init serial / LED       |                           |  - MQTT message callback   |\n|  - Init IMU / SD / RF      |                           |  - Timer / millis() event  |\n|  - WiFi + NTP + MQTT       |                           |                            |\n|                            |                           |                            |\n|  loop():                   |                           |                            |\n|  - Check node state        | &lt;--------- flags -------- |  - Set flags / schedule    |\n|  - Execute logic           | --------&gt; state change -&gt; |  - Modify state machine    |\n|  - Maintain MQTT (only GW) |                           |                            |\n|  - Transition states       |                           |                            |\n|                            |                           |                            |\n+============================+                           +============================+\n</code></pre>"},{"location":"SOFTWARE/IDE/ide/","title":"INTEGRATED DEVELOPMENT ENVIRONMENT (IDE)","text":"<p>Arduino Development Environment</p> <p>Arduino development can be done in various ways, with the most common being the Arduino IDE. The Arduino IDE is an open-source integrated development environment specifically designed for Arduino hardware. It provides a simple and user-friendly interface that allows users to write, compile, and upload code to Arduino boards. In recent years, PlatformIO has also become a popular choice; it is a cross-platform IDE that supports multiple development boards and frameworks. PlatformIO offers more powerful features such as library management, debugging support, and various compiler options. PlatformIO is actually a plugin for VSCode, which is a powerful code editor that supports multiple programming languages and extensions. The VSCode plugin ecosystem is very rich, allowing users to enhance its functionality by installing different plugins. Given this, this project uses VSCode + PlatformIO as the primary development environment.</p>"},{"location":"SOFTWARE/IDE/ide/#vscode-installation","title":"VSCode Installation","text":"<ul> <li> <p> VSCode</p> <p>  Download Link </p> </li> </ul>"},{"location":"SOFTWARE/IDE/ide/#platformio-installation","title":"PlatformIO Installation","text":"<ul> <li> <p> PlatformIO Installation</p> <p>  Installation Guidance </p> </li> </ul>"},{"location":"SOFTWARE/IDE/ide/#developing-arduino-projects-with-vscode-platformio","title":"Developing Arduino Projects with VSCode + PlatformIO","text":"<ul> <li> <p> Creating Arduino Projects with PlatformIO</p> <p>  Documentation Tutorial </p> <p>  Video Tutorial </p> </li> </ul>"},{"location":"SOFTWARE/PROGRAMMING/programming/","title":"PROGRAMMING","text":""},{"location":"SOFTWARE/PROGRAMMING/programming/#create-a-new-project","title":"Create a New Project","text":"<p>Generally, if you don't have a project yet, you can create one by following the steps shown in the images:</p> <ol> <li> <p>Click the PlatformIO icon on the left to bring up the PlatformIO panel at the bottom.</p> </li> <li> <p>Click the home icon in the PlatformIO panel to go to the PlatformIO home page.</p> </li> <li> <p>Click the \"New Project\" button, enter the project name, and select the development board and framework.</p> </li> </ol>"},{"location":"SOFTWARE/PROGRAMMING/programming/#import-a-project","title":"Import a Project","text":"<p>If you already have a project, you can open the project folder in the PlatformIO environment. First, we need to obtain the code for this project, which can be done in two ways:</p> <ol> <li>Clone the project code to your local machine using Git. Open a terminal and enter the following command:</li> </ol> <pre><code>git clone https://github.com/Shuaiwen-Cui/ArduinoNode.git\n</code></pre> <p>Note</p> <p>The project contains a folder named 'APESS2025-CODE', which is the code for this project. A compressed file with the same name also contains the same code. Both have identical content.  </p> <ol> <li>Download the project code as a compressed file from GitHub, then unzip it and open the folder.</li> </ol> <p></p>"},{"location":"SOFTWARE/PROGRAMMING/programming/#programming-in-the-ide","title":"Programming in the IDE","text":"<p>After opening the project in PlatformIO, the left side shows the file explorer. The <code>lib</code> folder is particularly important as it contains the libraries used in this project, and the <code>src</code> folder contains the source code. At the bottom of the page are quick access buttons, with three key functions: Compile, Upload, and Serial Monitor.</p>"},{"location":"SOFTWARE/PROGRAMMING/programming/#arduino-programming","title":"Arduino Programming","text":"<p><pre><code>#include &lt;Arduino.h&gt; // unlike Arduino IDE, PlatformIO requires this header file\nvoid setup() \n{\n  // Initialize the serial communication at 9600 baud\n  Serial.begin(9600);\n}\nvoid loop() \n{\n  // Print \"Hello, World!\" to the Serial Monitor\n  Serial.println(\"Hello, World!\");\n\n  // Wait for 1 second (1000 milliseconds)\n  delay(1000);\n}\n</code></pre> In the code above, the basic framework for microcontroller programming consists of \"initialization\" and \"infinite loop,\" which differs from computer programming that requires an exit mechanism. In the Arduino development framework, the <code>setup()</code> function is used for initialization, while the <code>loop()</code> function contains code that runs in an infinite loop. After uploading the code, the microcontroller automatically runs the <code>setup()</code> function once and then enters the <code>loop()</code> function.</p> <pre><code>void setup() \n{\n    // Initialization\n}\n\nvoid loop() \n{\n    // Infinite loop\n}\n</code></pre>"},{"location":"SOFTWARE/SENSING-STORAGE/sensing/","title":"ACCELERATION SENSING","text":"<p>Sampling can be said to be one of the most important functions of this project. It allows us to collect and store data from sensors for subsequent analysis and processing. Since Arduino performance is very limited, this project uses a method of sampling and storing at the same time to achieve data collection. Since there is no real-time operating system, the storage process will have a certain impact on sampling, so a high sampling frequency cannot be achieved, but due to the demonstration and teaching nature of this project, the sampling frequency does not need to be very high. After testing, a sampling frequency of 200Hz can be fully achieved, and since it is sampling and storing at the same time, the data limit is basically equivalent to the capacity of the SD card.</p> <p>As shown in the code above, the sampling process is divided into several stages:</p> <ol> <li> <p>Sampling start time and end time: This part is completed when the MQTT command callback is called.</p> </li> <li> <p>calling <code>sensing_prepare()</code>: called at the preparation state, opens the SD card file and writes the sampling metadata. In this function, a <code>load_log_number()</code> function is called to load the current log number and use it in the file name. The file name format is <code>N001_001.txt</code>, where <code>N001</code> is the node ID and <code>001</code> is the log number. There is a file in the SD card that records the current log number, which will automatically increase after the sampling is completed.</p> </li> <li> <p>calling <code>sensing_sample_once()</code>: called repeatedly in the sampling state, reads the sensor data and writes it to the SD card file. Each sampling will check whether the set sampling rate (<code>sensing_rate_hz</code>) is reached. If it is reached, the sensor data is read and written to the file. In the main program loop, when the current time minus the last sampling time is greater than or equal to <code>1000 / sensing_rate_hz</code>, a sampling is performed. The sampling data includes the timestamp and the three axial data of the accelerometer (ax, ay, az), and is written to the SD card file.</p> </li> <li> <p>calling <code>sensing_stop()</code>: Called at the end of the sampling state, closes the SD card file and prints the sampling results. This function prints the total number of samples and reopens the file content for printing to the serial port.</p> </li> </ol> <p>Info</p> <p>In this project, since the serial port output speed is very slow, it will drag down the sampling and storage, so during the sampling process, we only do storage without serial port output. After the sampling is completed, the file can be reopened and the content can be printed to the serial port.</p>"},{"location":"SOFTWARE/SENSING-STORAGE/storage/","title":"STORAGE","text":"<p>This project uses an SD card for data storage, and due to the limitations of Arduino memory, sampling and storage are performed simultaneously. Details can be found in the explanation of the sensing section.</p>"},{"location":"SOFTWARE/SENSING-STORAGE/uploading/","title":"DATA UPLOADING","text":"<p>Since it is an Internet project, we can upload data to the server through the Internet. Since we have introduced the MQTT protocol, we can upload data to the server through the MQTT protocol. However, please note that due to the limitations of the MQTT protocol, we cannot directly upload the entire file, but need to divide the file into multiple small blocks for uploading. In addition, the current data upload is based on server-side requests, that is, the node will listen to the server-side request, and when the server-side requests data, the node will upload the data to the server. The core code is in sensing.cpp.</p> <p>Note</p> <p>If each node is connected to the Internet, then the sampling file can be uploaded to the server in the manner described above. However, it has been found that mobile hotspots often cannot cover all nodes in actual deployment, so currently data is only stored on the SD card. The data from the main node can be directly uploaded to the server because it is connected to the MQTT server. The data from other nodes needs to be forwarded through the main node, but this involves complex communication programming development, and the transmission process takes much longer than the sampling time, which is not implemented in this project for now.</p> <pre><code>void sensing_retrieve_file()\n{\n    File file = SD.open(retrieval_filename, FILE_READ);\n    if (!file)\n    {\n        Serial.print(\"[Error] File not found: \");\n        Serial.println(retrieval_filename);\n        return;\n    }\n\n    Serial.print(\"[Retrieval] Reading file: \");\n    Serial.println(retrieval_filename);\n\n    size_t total_size = file.size();\n    size_t bytes_sent = 0;\n    size_t chunk_size = 850;\n    size_t chunk_index = 1;\n    size_t chunk_total = (total_size + chunk_size - 1) / chunk_size;\n\n    char prefix[32];\n    snprintf(prefix, sizeof(prefix), \"%s\", retrieval_filename + 1); // Remove leading '/'\n    char topic[64];\n\n    while (file.available())\n    {\n        char buffer[851]; // chunk_size + 1 for null terminator\n        size_t len = file.readBytes(buffer, chunk_size);\n        buffer[len] = '\\0';\n\n        snprintf(topic, sizeof(topic), \"%s[%d/%d]:\", prefix, chunk_index, chunk_total);\n        String payload = String(topic) + String(buffer);\n\n        bool ok = mqtt_client.publish(MQTT_TOPIC_PUB, payload.c_str());\n        if (ok)\n        {\n            bytes_sent += len;\n            Serial.print(\"[MQTT] Sent chunk \");\n            Serial.print(chunk_index);\n            Serial.print(\" / \");\n            Serial.print(chunk_total);\n            Serial.print(\" (\");\n            Serial.print(bytes_sent);\n            Serial.print(\" / \");\n            Serial.print(total_size);\n            Serial.println(\" bytes)\");\n        }\n        else\n        {\n            Serial.print(\"[Error] Failed to send chunk \");\n            Serial.println(chunk_index);\n        }\n\n        chunk_index++;\n\n        mqtt_loop(); // keep MQTT alive\n        delay(50);   // throttle\n    }\n\n    file.close();\n\n    String done_msg = String(prefix) + \"[done]\";\n    mqtt_client.publish(MQTT_TOPIC_PUB, done_msg.c_str());\n    Serial.println(\"[MQTT] File upload completed.\");\n\n    node_status.node_flags.data_retrieval_requested = false;\n    node_status.node_flags.data_retrieval_sent = true;\n}\n</code></pre>"},{"location":"SOFTWARE/STATEMACHINE/statemachine/","title":"STATE MACHINE AND INDICATORS","text":"<p>Without the introduction of a real-time operating system, a state machine is a common method for implementing complex logic. It manages system behavior by defining states and transitions between states. A state machine can help simplify the code structure and make the logic clearer and easier to understand.</p>"},{"location":"SOFTWARE/STATEMACHINE/statemachine/#design-explanation","title":"Design Explanation","text":"<p>In this project, the core is to distinguish between sampling and non-sampling states. Since the sampling state consumes more resources, some operations in the non-sampling state may lead to system instability if performed during the sampling state. Therefore, a clear distinction is necessary. The non-sampling states are further divided into startup, idle, preparing, WIFI communicating, RF communication, and error states. After the device completes initialization, each loop first determines the current state to execute the corresponding operations. In addition to states, we define a series of flags to assist the state machine in state transitions and operations.</p> <p>In terms of implementation, we can define some structures and a state machine class that includes the current state, flags, and methods to set the state and print state information. Through this approach, we can clearly manage the node's state and related flags in the code.</p>"},{"location":"SOFTWARE/STATEMACHINE/statemachine/#state-transition-map","title":"State Transition Map","text":"<pre><code>stateDiagram-v2\n    [*] --&gt; BOOT\n    BOOT --&gt; WIFI_COMMUNICATING: (Gateway only) Setup WiFi &amp; NTP\n    BOOT --&gt; RF_COMMUNICATING: RF init success\n    RF_COMMUNICATING --&gt; IDLE: RF time sync success\n    RF_COMMUNICATING --&gt; ERROR: RF time sync failed\n    WIFI_COMMUNICATING --&gt; IDLE: NTP sync or file upload complete\n    IDLE --&gt; PREPARING: sensing_scheduled &amp; time ready\n    PREPARING --&gt; SAMPLING: start time reached\n    SAMPLING --&gt; IDLE: sampling complete\n    any_state --&gt; WIFI_COMMUNICATING: CMD_NTP / CMD_RETRIEVAL\n    any_state --&gt; BOOT: CMD_REBOOT\n    any_state --&gt; RF_COMMUNICATING: CMD_RF_SYNC\n    any_state --&gt; ERROR: sensing_start failed</code></pre>"},{"location":"SOFTWARE/STATEMACHINE/statemachine/#related-code","title":"Related Code","text":""},{"location":"SOFTWARE/STATEMACHINE/statemachine/#nodestatehpp","title":"nodestate.hpp","text":"<pre><code>#pragma once\n\n// === Mutually exclusive node states ===\nenum class NodeState\n{\n    BOOT,\n    IDLE, // routine operation &amp; monitoring\n    PREPARING, // no routine operation, preparing for sensing\n    SAMPLING, // actively sampling data\n    RF_COMMUNICATING, // communicating with other nodes via RF\n    WIFI_COMMUNICATING, // communicating with server via WiFi\n    ERROR // error state\n};\n\n// === Non-mutually-exclusive status flags ===\nstruct NodeFlags\n{\n    // Reboot Flags\n    bool reboot_required_gateway = false; // Reboot command received for gateway\n    bool reboot_required_leafnode = false; // Reboot command received for leaf node\n\n    // Initialization Flags\n    bool serial_ready = false;    // Serial communication ready status\n    bool led_ready = false;       // LED ready status\n    bool imu_ready = false;       // IMU sensor ready status\n    bool rf_ready = false;        // RF communication ready status\n    bool sd_ready = false;         // SD card ready status\n\n    // Key Connection Flags\n    bool wifi_connected = false;   // WiFi connection status\n    bool mqtt_connected = false;   // MQTT connection status\n\n    // Time Synchronization Flags\n    bool time_ntp_synced = false;   // NTP time synchronization status\n    bool time_rf_synced = false;   // RF time synchronization status\n    bool gateway_ntp_required = false; // Gateway NTP required status\n    bool leafnode_ntp_required = false; // Leaf node NTP required status\n    bool time_rf_required = false; // RF time sync required status\n\n    // Sensing Flags\n    bool sensing_requested = false; // Sensing command received status\n    bool sensing_scheduled = false; // Sensing schedule status\n    bool sensing_active = false;    // Sensing activity status\n\n    // Data Logging Flags\n    bool data_retrieval_requested = false; // Data retrieval request status\n    bool data_retrieval_sent = true; // Data retrieval sent status, by default true, meaning already sent\n};\n\n// === State Manager ===\nclass NodeStatusManager\n{\npublic:\n    // Current state &amp; flags\n    NodeState node_state;\n    NodeFlags node_flags;\n\n    // Constructor\n    NodeStatusManager();\n\n    // State setters\n    void set_state(NodeState new_state);\n    NodeState get_state() const;\n\n    // Debug print\n    void print_state() const;\n};\n\n// Global instance\nextern NodeStatusManager node_status;\n</code></pre>"},{"location":"SOFTWARE/STATEMACHINE/statemachine/#nodestatecpp","title":"nodestate.cpp","text":"<pre><code>#include &lt;Arduino.h&gt;\n#include \"nodestate.hpp\"\n\n// Define the global instance\nNodeStatusManager node_status;\n\n// Constructor implementation\nNodeStatusManager::NodeStatusManager()\n{\n    node_state = NodeState::BOOT;\n\n    // All flags initialized to false by default via struct default values\n}\n\n// Set current node state\nvoid NodeStatusManager::set_state(NodeState new_state)\n{\n    node_state = new_state;\n}\n\n// Get current node state\nNodeState NodeStatusManager::get_state() const\n{\n    return node_state;\n}\n\n// Print current state and flags\nvoid NodeStatusManager::print_state() const\n{\n    Serial.print(\"[STATUS] Current state: \");\n    switch (node_state)\n    {\n    case NodeState::BOOT:\n        Serial.println(\"BOOT\");\n        break;\n    case NodeState::IDLE:\n        Serial.println(\"IDLE\");\n        break;\n    case NodeState::PREPARING:\n        Serial.println(\"PREPARING\");\n        break;\n    case NodeState::SAMPLING:\n        Serial.println(\"SAMPLING\");\n        break;\n    case NodeState::RF_COMMUNICATING:\n        Serial.println(\"RF_COMMUNICATING\");\n        break;\n    case NodeState::WIFI_COMMUNICATING:\n        Serial.println(\"WIFI_COMMUNICATING\");\n        break;\n    case NodeState::ERROR:\n        Serial.println(\"ERROR\");\n        break;\n    default:\n        Serial.println(\"UNKNOWN\");\n        break;\n    }\n\n    Serial.println(\"&lt;NodeFlags&gt; Initialization:\");\n    Serial.print(\"  Serial Ready: \");\n    Serial.println(node_flags.serial_ready ? \"Yes\" : \"No\");\n    Serial.print(\"  LED Ready:    \");\n    Serial.println(node_flags.led_ready ? \"Yes\" : \"No\");\n    Serial.print(\"  IMU Ready:    \");\n    Serial.println(node_flags.imu_ready ? \"Yes\" : \"No\");\n    Serial.print(\"  RF Ready:     \");\n    Serial.println(node_flags.rf_ready ? \"Yes\" : \"No\");\n    Serial.print(\"  SD Ready:     \");\n    Serial.println(node_flags.sd_ready ? \"Yes\" : \"No\");\n\n    Serial.println(\"&lt;NodeFlags&gt; Connection:\");\n    Serial.print(\"  WiFi:         \");\n    Serial.println(node_flags.wifi_connected ? \"Yes\" : \"No\");\n    Serial.print(\"  MQTT:         \");\n    Serial.println(node_flags.mqtt_connected ? \"Yes\" : \"No\");\n\n    Serial.println(\"&lt;NodeFlags&gt; Time Sync:\");\n    Serial.print(\"  NTP:          \");\n    Serial.println(node_flags.time_ntp_synced ? \"Yes\" : \"No\");\n    Serial.print(\"  RF:           \");\n    Serial.println(node_flags.time_rf_synced ? \"Yes\" : \"No\");\n\n    Serial.println();\n}\n</code></pre>"},{"location":"SOFTWARE/TIME-MANAGEMENT/time/","title":"TIME","text":"<p>Time management is an important research area in wireless sensor networks. It involves how to effectively coordinate and schedule nodes in the network to achieve efficient data collection, transmission, and processing. In this section, we will introduce some basic time management concepts, and time synchronization will be discussed in detail in other chapters.</p> <p>Before we delve into detailed discussion, let's first investigate the related codes:</p> <p>time.hpp</p> <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n\n/*\n * CalendarTime - Struct representing human-readable date and time.\n */\ntypedef struct\n{\n    /* === Calendar Fields === */\n    uint16_t year;   // Year (e.g., 2025)\n    uint8_t month;   // Month [1-12]\n    uint8_t day;     // Day [1-31]\n    uint8_t hour;    // Hour [0-23]\n    uint8_t minute;  // Minute [0-59]\n    uint8_t second;  // Second [0-59]\n    int32_t ms;      // Milliseconds [0-999]\n} CalendarTime;\n\n\nCalendarTime calendar_from_unix_seconds(uint64_t unix_seconds);\nCalendarTime calendar_from_unix_milliseconds(uint64_t unix_ms);\nuint64_t unix_from_calendar_seconds(const CalendarTime &amp;cal);\nuint64_t unix_from_calendar_milliseconds(const CalendarTime &amp;cal);\nCalendarTime YYMMDDHHMMSS2Calendar(const char *datetime12);\n\n/*\n * NodeTime - Unified time structure for embedded systems.\n * Provides both UNIX timestamp and human-readable calendar format.\n */\nclass NodeTime\n{\npublic:\n    /* === Running Time === */\n    uint64_t running_time;             // Local running time in milliseconds since node startup\n\n    /* === Time Tracking === */\n    uint64_t last_sync_running_time;  // Running time when last sync occurred\n\n    /* === Unified Time === */\n    float drift_ratio;                // Clock drift ratio, applied as: adjusted = base * (1 + drift_ratio)\n    uint64_t time_offset;             // Time offset in milliseconds for unified time correction\n    uint64_t unified_time;            // Unified network time (in milliseconds)\n    CalendarTime calendar_time;       // Human-readable calendar time\n\npublic:\n    /* === Constructors === */\n    NodeTime();\n\n    /* === Setters === */\n    void record_sync_time();\n\n    /* === Getters === */\n    uint64_t get_time();                // Get current unified time\n    CalendarTime get_calendar();       // Get calendar time (stub for now, no RTC parsing)\n\n    /* === Printout === */\n    void show_time();\n};\n\nextern NodeTime Time;  // Global instance of NodeTime\n</code></pre> <p>time.cpp</p> <pre><code>#include \"time.hpp\"\n\n/* === Helper Functions === */\nCalendarTime calendar_from_unix_seconds(uint64_t unix_seconds)\n{\n    CalendarTime cal;\n    uint64_t seconds = unix_seconds;\n\n    cal.second = seconds % 60;\n    seconds /= 60;\n    cal.minute = seconds % 60;\n    seconds /= 60;\n    cal.hour = seconds % 24;\n    seconds /= 24; // Total days since epoch\n\n    int year = 1970;\n    while (true)\n    {\n        bool is_leap = (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0));\n        int days_in_year = is_leap ? 366 : 365;\n        if (seconds &gt;= days_in_year)\n        {\n            seconds -= days_in_year;\n            year++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    cal.year = year;\n\n    static const uint8_t days_in_month[12] = {\n        31, 28, 31, 30, 31, 30,\n        31, 31, 30, 31, 30, 31};\n\n    int month = 0;\n    while (month &lt; 12)\n    {\n        int dim = days_in_month[month];\n        if (month == 1 &amp;&amp; (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0)))\n            dim = 29;\n\n        if (seconds &gt;= dim)\n        {\n            seconds -= dim;\n            month++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    cal.month = month + 1;\n    cal.day = seconds + 1;\n    cal.ms = 0;\n\n    return cal;\n}\n\nCalendarTime calendar_from_unix_milliseconds(uint64_t unix_ms)\n{\n    CalendarTime cal = calendar_from_unix_seconds(unix_ms / 1000);\n    cal.ms = unix_ms % 1000;\n    return cal;\n}\n\nuint64_t unix_from_calendar_seconds(const CalendarTime &amp;cal)\n{\n    uint64_t days = 0;\n\n    for (int y = 1970; y &lt; cal.year; ++y)\n    {\n        bool is_leap = (y % 4 == 0 &amp;&amp; (y % 100 != 0 || y % 400 == 0));\n        days += is_leap ? 366 : 365;\n    }\n\n    static const uint8_t days_in_month[12] = {\n        31, 28, 31, 30, 31, 30,\n        31, 31, 30, 31, 30, 31};\n\n    for (int m = 0; m &lt; cal.month - 1; ++m)\n    {\n        if (m == 1 &amp;&amp; (cal.year % 4 == 0 &amp;&amp; (cal.year % 100 != 0 || cal.year % 400 == 0)))\n            days += 29;\n        else\n            days += days_in_month[m];\n    }\n\n    days += (cal.day - 1);\n\n    return days * 86400ULL + cal.hour * 3600 + cal.minute * 60 + cal.second;\n}\n\nuint64_t unix_from_calendar_milliseconds(const CalendarTime &amp;cal)\n{\n    return unix_from_calendar_seconds(cal) * 1000ULL + cal.ms;\n}\n\n// Convert YYMMDDHHMMSS string to CalendarTime structure\nCalendarTime YYMMDDHHMMSS2Calendar(const char *datetime12)\n{\n    CalendarTime ct = {0};\n\n    if (strlen(datetime12) != 12) {\n        // Return a zero-initialized CalendarTime on failure\n        return ct;\n    }\n\n    char buf[3] = {0};\n\n    // Extract and convert each part of the datetime string\n    strncpy(buf, datetime12, 2);\n    ct.year = 2000 + atoi(buf);  // YY \u2192 20YY\n    strncpy(buf, datetime12 + 2, 2);\n    ct.month = atoi(buf);\n    strncpy(buf, datetime12 + 4, 2);\n    ct.day = atoi(buf);\n    strncpy(buf, datetime12 + 6, 2);\n    ct.hour = atoi(buf);\n    strncpy(buf, datetime12 + 8, 2);\n    ct.minute = atoi(buf);\n    strncpy(buf, datetime12 + 10, 2);\n    ct.second = atoi(buf);\n\n    ct.ms = 0;  // Milliseconds are set to 0 as per the original function\n\n    return ct;\n}\n\n/* === Major Functions === */\nNodeTime::NodeTime()\n{\n    running_time = 0;\n    last_sync_running_time = 0;\n    drift_ratio = 1.0f; // Default drift ratio (no drift)\n    time_offset = 0;    // Default time offset\n    unified_time = 0;\n    calendar_time = {0, 0, 0, 0, 0, 0, 0}; // Initialize calendar time to zero\n}\n\nvoid NodeTime::record_sync_time()\n{\n    last_sync_running_time = millis(); // Record the current running time\n}\n\n\n\n// uint64_t NodeTime::get_time()\n// {\n//     running_time = millis(); // Get the current running time in milliseconds\n//     unified_time = static_cast&lt;uint64_t&gt;((drift_ratio * (running_time - last_sync_running_time)) + time_offset);\n//     return unified_time;\n// }\n\n// uint64_t NodeTime::get_time()\n// {\n//     running_time = millis();\n\n//     // Use double to preserve precision during multiplication\n//     double delta = static_cast&lt;double&gt;(running_time - last_sync_running_time);\n//     return static_cast&lt;uint64_t&gt;(delta * drift_ratio + static_cast&lt;double&gt;(time_offset));\n// }\n\n// uint64_t NodeTime::get_time()\n// {\n//     running_time = millis();\n\n//     // Use double to preserve precision during multiplication\n//     double delta = static_cast&lt;double&gt;(running_time - last_sync_running_time);\n\n//     // Include last_sync_running_time in the return value\n//     double adjusted_time = delta * drift_ratio + static_cast&lt;double&gt;(time_offset);\n\n//     // Return the result as uint64_t\n//     return static_cast&lt;uint64_t&gt;(adjusted_time);\n// }\n\n\nuint64_t NodeTime::get_time()\n{\n    running_time = millis();\n\n    // Use double to preserve precision during multiplication\n    double delta = static_cast&lt;double&gt;(running_time - last_sync_running_time);\n\n    // Include last_sync_running_time in the return value\n    double adjusted_time = static_cast&lt;double&gt;(last_sync_running_time) + delta * drift_ratio + static_cast&lt;double&gt;(time_offset);\n\n    // Return the result as uint64_t\n    return static_cast&lt;uint64_t&gt;(adjusted_time);\n}\n\nCalendarTime NodeTime::get_calendar()\n{\n    uint64_t current_time = get_time(); // Milliseconds since 1970-01-01 00:00:00 UTC\n    uint64_t ms_total = current_time;\n\n    calendar_time.ms = ms_total % 1000;\n    time_t seconds = ms_total / 1000;\n\n    // === Extract time ===\n    calendar_time.second = seconds % 60;\n    seconds /= 60;\n    calendar_time.minute = seconds % 60;\n    seconds /= 60;\n    calendar_time.hour = seconds % 24;\n    seconds /= 24; // Now we have total days since epoch\n\n    // === Extract date ===\n    int year = 1970;\n    while (true)\n    {\n        bool is_leap = (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0));\n        int days_in_year = is_leap ? 366 : 365;\n        if (seconds &gt;= days_in_year)\n        {\n            seconds -= days_in_year;\n            year++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    calendar_time.year = year;\n\n    static const uint8_t days_in_month[12] = {\n        31, 28, 31, 30, 31, 30,\n        31, 31, 30, 31, 30, 31};\n\n    int month = 0;\n    while (month &lt; 12)\n    {\n        int dim = days_in_month[month];\n\n        // Adjust for leap year in February\n        if (month == 1 &amp;&amp; (year % 4 == 0 &amp;&amp; (year % 100 != 0 || year % 400 == 0)))\n            dim = 29;\n\n        if (seconds &gt;= dim)\n        {\n            seconds -= dim;\n            month++;\n        }\n        else\n        {\n            break;\n        }\n    }\n    calendar_time.month = month + 1; // [1-12]\n    calendar_time.day = seconds + 1; // [1-31]\n\n    return calendar_time;\n}\n\nvoid NodeTime::show_time()\n{\n    // Update current times\n    running_time = millis();\n    uint64_t now = get_time();\n\n    // Use unified function for calendar conversion\n    CalendarTime cal = calendar_from_unix_milliseconds(now);\n\n    Serial.println(\"=== Node Time Info ===\");\n\n    Serial.print(\"Running Time      : \");\n    Serial.print(running_time);\n    Serial.println(\" ms\");\n\n    Serial.print(\"Unified Time      : \");\n    Serial.print(now);\n    Serial.println(\" ms\");\n\n    Serial.print(\"Calendar Time     : \");\n    Serial.print(cal.year);\n    Serial.print(\"-\");\n    if (cal.month &lt; 10)\n        Serial.print(\"0\");\n    Serial.print(cal.month);\n    Serial.print(\"-\");\n    if (cal.day &lt; 10)\n        Serial.print(\"0\");\n    Serial.print(cal.day);\n    Serial.print(\" \");\n\n    if (cal.hour &lt; 10)\n        Serial.print(\"0\");\n    Serial.print(cal.hour);\n    Serial.print(\":\");\n    if (cal.minute &lt; 10)\n        Serial.print(\"0\");\n    Serial.print(cal.minute);\n    Serial.print(\":\");\n    if (cal.second &lt; 10)\n        Serial.print(\"0\");\n    Serial.print(cal.second);\n    Serial.print(\".\");\n    if (cal.ms &lt; 100)\n        Serial.print(\"0\");\n    if (cal.ms &lt; 10)\n        Serial.print(\"0\");\n    Serial.println(cal.ms);\n\n    Serial.println(\"======================\");\n}\n\nNodeTime Time;\n</code></pre>"},{"location":"SOFTWARE/TIME-MANAGEMENT/time/#time-representation","title":"Time Representation","text":""},{"location":"SOFTWARE/TIME-MANAGEMENT/time/#natural-timekeeping","title":"Natural Timekeeping","text":"<p>Natural timekeeping refers to using calendar and clock formats familiar to humans to represent time. This usually includes fields such as year, month, day, hour, minute, and second. While this format is easy for humans to understand and use, it may not be efficient for computer systems to process.</p>"},{"location":"SOFTWARE/TIME-MANAGEMENT/time/#unix-time","title":"Unix Time","text":"<p>Unix time refers to the number of seconds that have elapsed since January 1, 1970, 00:00:00 UTC. It is a standard time representation widely used in computer systems. The advantage of Unix time is that it is easy to compute and compare, although it is not easily readable by humans. Network time synchronization typically uses Unix time to align system clocks.</p>"},{"location":"SOFTWARE/TIME-MANAGEMENT/time/#runtime","title":"Runtime","text":"<p>Runtime refers to the duration from system startup to the current moment, usually measured in milliseconds. It is particularly important in real-time systems and embedded devices, as it helps monitor system status and performance. Most hardware platforms provide a timer to track runtime.</p> <p>Note</p> <p>In practical applications, natural timekeeping and Unix time are often converted between each other. Natural time is used when human-readable output is needed, while Unix time is preferred for efficient computation. In this project, while high precision is not strictly required, we adopt millisecond-level time representation to ensure reliable functionality.</p> <p>Summary</p> <p>From the perspective of time representation, all three methods have their strengths and weaknesses. Natural time is human-friendly but inefficient for machines; Unix time is computation-friendly but hard to read; runtime offers high precision but is relative to system startup time. For wireless sensor networks, synchronization between nodes is often needed.</p> <p>To meet these requirements, we define a unified time structure called <code>NodeTime</code> in the <code>time</code> module. It includes fields for Unix time, natural time, and runtime, along with helper functions to support time conversion and calculation.</p> <p>To facilitate time management, we define three key time variables:</p> <ul> <li><code>Time</code>: A global time variable that represents the current system time.</li> </ul>"},{"location":"SOFTWARE/TIME-MANAGEMENT/timesync/","title":"TIME SYNCHRONIZATION","text":"<p>Time synchronization is critical for wireless network devices. It ensures time consistency between devices so that timestamps, logging, and other time-related functions of data packets can work correctly. In this project, time synchronization is divided into two parts: the first part is time synchronization with the Internet, and the second part is time synchronization between devices.</p> <p>The related codes are shown below:</p> <p>time.hpp</p> <pre><code>#pragma once\n#include &lt;Arduino.h&gt;\n#include \"config.hpp\"\n#include \"nodestate.hpp\"\n\n#define SYNC_ROUNDS 7\n#define SYNC_INTERVAL_1 20000\n#define SYNC_INTERVAL_N 2000\n#define TIME_SYNC_RESERVED_TIME 60000 // means reserve at least 60 seconds for time sync when issuing a sensing command\n\n/*\n * Time synchronization header\n * \n * Provides:\n * - NTP synchronization function\n * - RF time synchronization function by drift ratio and offset\n */\n\nbool sync_time_ntp();\nbool rf_time_sync();\n</code></pre> <p>time.cpp</p> <p><pre><code>#include &lt;WiFiUdp.h&gt;\n#include &lt;NTPClient.h&gt;\n#include \"time.hpp\"\n#include \"timesync.hpp\"\n#include \"rf.hpp\"\n\nWiFiUDP ntpUDP;\nNTPClient timeClient(ntpUDP, \"asia.pool.ntp.org\", 28800, 60000);\n\nbool sync_time_ntp()\n{\n    timeClient.begin();\n    const uint64_t MIN_VALID_EPOCH = 1735689600; // 2025-01-01 00:00:00 UTC\n    bool success = false;\n\n    for (int attempt = 1; attempt &lt;= 5; ++attempt)\n    {\n        if (!timeClient.update())\n        {\n            Serial.print(\"[COMMUNICATION] &lt;NTP&gt; Attempt \");\n            Serial.print(attempt);\n            Serial.println(\": Failed to get NTP time.\");\n            delay(1000);\n            continue;\n        }\n\n        uint64_t epoch = timeClient.getEpochTime();\n        if (epoch &lt; MIN_VALID_EPOCH)\n        {\n            Serial.print(\"[COMMUNICATION] &lt;NTP&gt; Attempt \");\n            Serial.print(attempt);\n            Serial.print(\": Invalid epoch = \");\n            Serial.println(epoch);\n            delay(1000);\n            continue;\n        }\n\n        // === Valid time received ===\n        uint64_t now_millis = millis();\n        uint64_t epoch_ms = epoch * 1000ULL + now_millis % 1000ULL;\n\n        Time.last_sync_running_time = now_millis;\n        Time.time_offset = epoch_ms - now_millis;\n\n        Serial.print(\"[COMMUNICATION] &lt;NTP&gt; Synchronized UNIX epoch: \");\n        Serial.println(epoch);\n\n        Serial.println(\"[COMMUNICATION] &lt;NTP&gt; Local time (Calendar): \");\n        Time.show_time(); // Print calendar and unified time\n\n        success = true;\n        break;\n    }\n\n    if (!success)\n    {\n        Serial.println(\"[COMMUNICATION] &lt;NTP&gt; Final NTP sync failed after 5 attempts.\");\n    }\n\n    return success;\n}\n\nbool rf_time_sync()\n{\n#ifdef GATEWAY\n    Serial.println(\"[SYNC] Start time synchronization as GATEWAY\");\n\n    for (uint8_t round = 0; round &lt; SYNC_ROUNDS; ++round)\n    {   \n        for (uint8_t node_id = 1; node_id &lt;= NUM_NODES; ++node_id)\n        {\n            if (node_id == NODE_ID)\n                continue;\n\n            RFMessage msg;\n            msg.from_id = NODE_ID;\n            msg.to_id = node_id;\n\n            uint64_t current_time = Time.get_time();\n\n            uint32_t high = current_time &gt;&gt; 32;\n            uint32_t low = current_time &amp; 0xFFFFFFFF;\n            snprintf(msg.payload, sizeof(msg.payload), \"SYNC %lu %lu\", high, low);\n            msg.timestamp_ms = current_time;\n\n            rf_stop_listening();\n            rf_send(node_id, msg, false);\n            rf_start_listening();\n\n            Serial.print(\"[SYNC][GATEWAY] Round \");\n            Serial.print(round + 1);\n            Serial.print(\" \u2192 Node \");\n            Serial.print(node_id);\n            Serial.print(\" | Time = \");\n            Serial.println(current_time);\n        }\n\n        if (round == 0)\n            delay(SYNC_INTERVAL_1);\n        else if (round &lt; SYNC_ROUNDS - 1)\n            delay(SYNC_INTERVAL_N);\n    }\n\n    Serial.println(\"[SYNC] GATEWAY time synchronization complete.\");\n    return true;\n#endif\n\n#ifdef LEAFNODE\n    Serial.println(\"[SYNC] Start time synchronization as LEAFNODE\");\n\n    // === Step 1: Initialize arrays for each round ===\n    uint64_t gateway_time[SYNC_ROUNDS] = {0};\n    uint64_t local_time[SYNC_ROUNDS] = {0};\n    int64_t time_diff[SYNC_ROUNDS] = {0};\n    uint8_t received = 0;\n\n    // === Step 2: Receive SYNC messages ===\n    while (received &lt; SYNC_ROUNDS)\n    {\n        RFMessage msg;\n        if (rf_receive(msg, 100))\n        {\n            if (strncmp(msg.payload, \"SYNC\", 4) == 0 &amp;&amp; msg.to_id == NODE_ID)\n            {\n                uint32_t high = 0, low = 0;\n                sscanf(msg.payload, \"SYNC %lu %lu\", &amp;high, &amp;low);\n                uint64_t gw_time = ((uint64_t)high &lt;&lt; 32) | low;\n                uint64_t local = millis();\n\n                gateway_time[received] = gw_time;\n                local_time[received] = local;\n                time_diff[received] = static_cast&lt;int64_t&gt;(gw_time - local);\n\n                // === Output the results for each round (except for the final round) ===\n                if (received &lt; SYNC_ROUNDS - 1)\n                {\n                    Serial.print(\"[SYNC][LEAF] Round \");\n                    Serial.print(received + 1);\n                    Serial.print(\" \u2192 Gateway Time: \");\n                    Serial.print(gw_time);\n                    Serial.print(\" ms, Local Time: \");\n                    Serial.print(local);\n                    Serial.print(\" ms, Time Diff: \");\n                    Serial.println(time_diff[received]);\n                }\n\n                received++;\n            }\n        }\n    }\n\n    // === Step 3: Calculate drift_ratio ===\n    double drift_sum = 0.0;\n    double drift_max = -1e9;\n    double drift_min = 1e9;\n    uint8_t drift_count = 0;\n\n    for (uint8_t i = 1; i &lt; SYNC_ROUNDS; ++i)\n    {\n        int64_t delta_t = static_cast&lt;int64_t&gt;(local_time[i] - local_time[0]);\n        int64_t delta_T = static_cast&lt;int64_t&gt;(gateway_time[i] - gateway_time[0]);\n\n        if (delta_t &lt;= 0) continue;  // prevent division by zero or negative time\n\n        // Calculate drift_ratio directly within the loop\n        double drift_i = (static_cast&lt;double&gt;(delta_T - delta_t)) / delta_t;\n        drift_sum += drift_i;\n        drift_count++;\n\n        if (drift_i &gt; drift_max) drift_max = drift_i;\n        if (drift_i &lt; drift_min) drift_min = drift_i;\n\n        // Debug prints for drift calculation\n        Serial.print(\"[SYNC][LEAF] Drift \");\n        Serial.print(i);\n        Serial.print(\" = \");\n        Serial.println(drift_i, 8);  // Show drift value to 8 decimal places\n    }\n\n    double drift_cleaned_sum = drift_sum - drift_max - drift_min;\n    double drift_avg = drift_cleaned_sum / (drift_count - 2);\n\n    // === Step 4: Calculate offset using average of time_diff after removing max and min ===\n    int64_t max_diff = time_diff[0];\n    int64_t min_diff = time_diff[0];\n    int64_t offset_sum = 0;\n\n    for (uint8_t i = 0; i &lt; SYNC_ROUNDS; ++i)\n    {\n        if (time_diff[i] &gt; max_diff) max_diff = time_diff[i];\n        if (time_diff[i] &lt; min_diff) min_diff = time_diff[i];\n        offset_sum += time_diff[i];\n    }\n\n    // Calculate offset average after removing max and min values\n    int64_t offset_cleaned_sum = offset_sum - max_diff - min_diff;\n    int64_t offset_avg = offset_cleaned_sum / (SYNC_ROUNDS - 2);\n\n    // === Step 5: Update drift_ratio and time_offset ===\n    Time.drift_ratio = 1.0 + drift_avg;\n    Time.time_offset = offset_avg;  // Directly use offset_avg for time_offset\n\n    // === Step 6: Record sync time and summary ===\n    Time.record_sync_time();  // Record synchronization time after updating offset\n\n    // === Output the final round result ===\n    Serial.print(\"[SYNC][LEAF] Final Round \");\n    Serial.print(SYNC_ROUNDS);\n    Serial.print(\" \u2192 Gateway Time: \");\n    Serial.print(gateway_time[SYNC_ROUNDS - 1]);\n    Serial.print(\" ms, Local Time: \");\n    Serial.print(local_time[SYNC_ROUNDS - 1]);\n    Serial.print(\" ms, Time Diff: \");\n    Serial.println(time_diff[SYNC_ROUNDS - 1]);\n\n    // Debug prints for final result\n    Serial.println(\"=== Time Sync Result ===\");\n    Serial.print(\"Drift Ratio       : \");\n    Serial.println(Time.drift_ratio, 8);  // Show drift ratio to 8 decimal places\n    Serial.print(\"Time Offset       : \");\n    Serial.println(Time.time_offset);\n\n    Serial.print(\"Last Sync @       : \");\n    Serial.println(Time.last_sync_running_time);\n    Serial.println(\"========================\");\n\n    return true;\n#endif\n\n}\n</code></pre> In this project, time synchronization is divided into two categories: 1. Synchronization with the internet (via NTP) 2. Synchronization between local devices (via RF communication and RTT)</p>"},{"location":"SOFTWARE/TIME-MANAGEMENT/timesync/#1-internet-time-synchronization-network-time-protocol-ntp","title":"1. Internet Time Synchronization \u2013 Network Time Protocol (NTP)","text":"<p>NTP (Network Time Protocol) is used to synchronize local device time with an accurate time source on the internet. The basic principle is:</p> <ul> <li>The local device sends a request and records the send time <code>t1</code></li> <li>The NTP server receives the request and records the server time <code>t2</code></li> <li>The server sends back the current time <code>t3</code></li> <li>The local device receives the response and records receive time <code>t4</code></li> </ul> <p>Using these timestamps, the local device can estimate the network delay and adjust its own time based on the server's response.</p> <p>The related function in this project is:</p>"},{"location":"SOFTWARE/TIME-MANAGEMENT/timesync/#sync_time_ntp","title":"<code>sync_time_ntp()</code>","text":"<p>This function uses the <code>NTPClient</code> library to retrieve the current Unix timestamp from the internet. Its core logic includes:</p> <ul> <li>Initialize and connect to the NTP server</li> <li>Retrieve the current UTC time (Unix timestamp)</li> <li>Update the global <code>Time</code> variable with the retrieved value</li> <li>Record the current runtime (e.g., from <code>millis()</code>) to enable millisecond-level tracking</li> </ul> <p>This function is called at device startup or when re-synchronization is needed. While it is convenient, it depends on internet access and the precision is limited to seconds on platforms like Arduino.</p>"},{"location":"SOFTWARE/TIME-MANAGEMENT/timesync/#2-local-device-time-synchronization-ftsp-flooding-time-synchronization-protocol","title":"2. Local Device Time Synchronization \u2013 FTSP (Flooding Time Synchronization Protocol)","text":"<p>This project implements a flooding-based time synchronization protocol (FTSP), where the gateway node periodically broadcasts its current time to all leaf nodes. Each leaf node receives the messages and calculates timing offset and clock drift to align its local time accordingly.</p> <p>The core steps of FTSP are as follows:</p> <ol> <li> <p>Gateway node broadcasts time information:    In each synchronization round, the gateway sends a 64-bit timestamp representing its current time to all leaf nodes.</p> </li> <li> <p>Leaf node receives the time message:    Upon reception, the leaf node continues the following steps.</p> </li> <li> <p>Record local receive time:    The leaf node records the timestamp of message arrival using its local <code>millis()</code> clock.</p> </li> <li> <p>Compute time offset:    The time difference between the gateway's timestamp and the local receive time is calculated as a candidate offset.</p> </li> <li> <p>Estimate clock drift:    Across multiple synchronization rounds, the leaf node estimates the drift ratio between the gateway and its own clock. This drift ratio reflects the rate difference between the two clocks.</p> </li> <li> <p>Update local time model:    Based on the calculated drift ratio and time offset, the node adjusts its internal time model to maintain synchronization.</p> </li> <li> <p>Record last sync time:    The last synchronization timestamp is stored to support accurate continuous time estimation.</p> </li> </ol>"},{"location":"SOFTWARE/TIME-MANAGEMENT/timesync/#summary","title":"Summary","text":"<p>To balance precision and practicality, the system is designed to first initialize the time using NTP and then maintain accurate synchronization between devices using RF-based FTSP.</p> <p>Note</p> <p>In practical deployments, NTP is typically used for initial time setup during device boot-up. RF-based synchronization ensures continued time consistency between nodes even in offline or unstable network conditions, achieving higher accuracy and robustness.</p>"},{"location":"SOFTWARE/TIME-MANAGEMENT/timesync/#serial-printout-example","title":"Serial Printout Example","text":"<p>Below is a typical startup process serial output example for the gateway node, showing key steps for time synchronization:</p> <p></p>"},{"location":"blog/","title":"Blog","text":""}]}